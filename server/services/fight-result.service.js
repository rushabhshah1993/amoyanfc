/**
 * Fight Result Service - Backend Implementation
 * 
 * This service handles ALL MongoDB updates after a fight result is generated by OpenAI.
 * It follows the exact same 8-step process as the frontend prepareFightResultPayload
 * to ensure data integrity and prevent corruption.
 * 
 * CRITICAL: All updates must succeed or ALL must rollback (transaction required)
 * 
 * @module services/fight-result.service
 */

import { Fighter } from '../models/fighter.model.js';
import { Competition } from '../models/competition.model.js';
import { CompetitionMeta } from '../models/competition-meta.model.js';
import { RoundStandings } from '../models/round-standings.model.js';

const POINTS_PER_WIN = 3;

/**
 * ====================================================================================
 * STEP 1-2: UPDATE COMPETITION FIGHT DOCUMENT
 * ====================================================================================
 * Updates the fight with winner, stats, date, descriptions
 */
async function updateCompetitionFight(
    competition,
    fight,
    generatedResult,
    isSimulated,
    userDescription,
    fightDate
) {
    console.log('\nüìù Step 1-2: Updating Competition Fight Document...');
    
    console.log('üìä Generated Result Object:');
    console.log('   - winnerId:', generatedResult.winnerId);
    console.log('   - genAIDescription:', generatedResult.genAIDescription ? `${generatedResult.genAIDescription.substring(0, 80)}...` : 'MISSING');
    console.log('   - fighterStats:', generatedResult.fighterStats?.length, 'fighters');
    if (generatedResult.fighterStats) {
        generatedResult.fighterStats.forEach((fs, idx) => {
            console.log(`   - Fighter ${idx + 1}: finishingMove = ${fs.stats?.finishingMove || 'null'}`);
        });
    }
    
    fight.winner = generatedResult.winnerId;
    fight.genAIDescription = generatedResult.genAIDescription;
    fight.isSimulated = isSimulated;
    fight.fighterStats = generatedResult.fighterStats;
    fight.fightStatus = 'completed';
    
    if (!isSimulated && userDescription) {
        fight.userDescription = userDescription;
    }
    
    if (fightDate) {
        fight.date = fightDate;
    } else if (!fight.date) {
        fight.date = new Date();
    }
    
    console.log(`\n   ‚úì Fight ${fight.fightIdentifier} updated`);
    console.log(`   ‚úì Winner: ${fight.winner}`);
    console.log(`   ‚úì Date: ${fight.date}`);
    console.log(`   ‚úì AI Description: ${fight.genAIDescription ? 'Saved (' + fight.genAIDescription.length + ' chars)' : 'MISSING'}`);
    console.log(`   ‚úì Fighter Stats: ${fight.fighterStats?.length || 0} fighters`);
    if (fight.fighterStats) {
        fight.fighterStats.forEach((fs, idx) => {
            console.log(`      - Fighter ${idx + 1}: finishingMove = ${fs.stats?.finishingMove || 'null'}`);
        });
    }
}

/**
 * ====================================================================================
 * STEP 3: UPDATE FIGHTER COMPETITION HISTORY
 * ====================================================================================
 * Updates totalFights, totalWins, totalLosses, winPercentage for this competition
 */
async function updateFighterCompetitionHistory(fighter, competitionMetaId, isWinner) {
    console.log(`\nüìä Step 3: Updating Competition History for ${fighter.firstName} ${fighter.lastName}...`);
    
    const competitionHistory = fighter.competitionHistory || [];
    const existingComp = competitionHistory.find(
        ch => ch.competitionId.toString() === competitionMetaId.toString()
    );
    
    if (existingComp) {
        existingComp.totalFights += 1;
        if (isWinner) {
            existingComp.totalWins += 1;
        } else {
            existingComp.totalLosses += 1;
        }
        existingComp.winPercentage = (existingComp.totalWins / existingComp.totalFights) * 100;
        
        console.log(`   ‚úì Updated existing: ${existingComp.totalWins}W-${existingComp.totalLosses}L (${existingComp.winPercentage.toFixed(2)}%)`);
    } else {
        // Create new competition entry
        fighter.competitionHistory.push({
            competitionId: competitionMetaId,
            totalFights: 1,
            totalWins: isWinner ? 1 : 0,
            totalLosses: isWinner ? 0 : 1,
            winPercentage: isWinner ? 100 : 0,
            numberOfSeasonAppearances: 1,
            titles: { totalTitles: 0, details: [] },
            seasonDetails: []
        });
        
        console.log(`   ‚ú® Created new competition history: ${isWinner ? '1W-0L' : '0W-1L'}`);
    }
}

/**
 * ====================================================================================
 * STEP 4: UPDATE FIGHTER SEASON DETAILS (LEAGUE ONLY)
 * ====================================================================================
 * Updates fights, wins, losses, points, winPercentage for this season/division
 */
async function updateFighterSeasonDetails(
    fighter,
    competitionMetaId,
    seasonNumber,
    divisionNumber,
    isWinner,
    competitionType
) {
    // Skip for cup competitions
    if (competitionType === 'cup') {
        console.log(`   ‚è≠Ô∏è  Step 4: Skipped season details (cup competition)`);
        return;
    }
    
    console.log(`\nüìà Step 4: Updating Season Details for ${fighter.firstName} ${fighter.lastName}...`);
    
    const competitionHistory = fighter.competitionHistory.find(
        ch => ch.competitionId.toString() === competitionMetaId.toString()
    );
    
    if (!competitionHistory) {
        console.error('   ‚ùå Competition history not found - this should not happen!');
        return;
    }
    
    const seasonDetails = competitionHistory.seasonDetails || [];
    const existingSeason = seasonDetails.find(
        sd => sd.seasonNumber === seasonNumber && sd.divisionNumber === divisionNumber
    );
    
    if (existingSeason) {
        existingSeason.fights += 1;
        if (isWinner) {
            existingSeason.wins += 1;
            existingSeason.points += POINTS_PER_WIN;
        } else {
            existingSeason.losses += 1;
        }
        existingSeason.winPercentage = (existingSeason.wins / existingSeason.fights) * 100;
        
        console.log(`   ‚úì Updated S${seasonNumber} D${divisionNumber}: ${existingSeason.wins}W-${existingSeason.losses}L, ${existingSeason.points} pts`);
    } else {
        competitionHistory.seasonDetails.push({
            seasonNumber,
            divisionNumber,
            fights: 1,
            wins: isWinner ? 1 : 0,
            losses: isWinner ? 0 : 1,
            points: isWinner ? POINTS_PER_WIN : 0,
            winPercentage: isWinner ? 100 : 0
        });
        
        console.log(`   ‚ú® Created new season details: S${seasonNumber} D${divisionNumber}`);
    }
}

/**
 * ====================================================================================
 * STEP 5-6: UPDATE FIGHTER OPPONENTS HISTORY
 * ====================================================================================
 * Updates head-to-head record with opponent and adds fight detail
 */
async function updateFighterOpponentsHistory(
    fighter,
    opponentId,
    competitionMetaId,
    seasonNumber,
    divisionNumber,
    roundNumber,
    fightId,
    isWinner,
    fightDate
) {
    console.log(`\nü•ä Step 5-6: Updating Opponents History for ${fighter.firstName} ${fighter.lastName}...`);
    
    const opponentsHistory = fighter.opponentsHistory || [];
    const existingOpponent = opponentsHistory.find(
        oh => oh.opponentId.toString() === opponentId.toString()
    );
    
    const newDetail = {
        competitionId: competitionMetaId,
        season: seasonNumber,
        divisionId: divisionNumber,  // MongoDB schema uses divisionId
        roundId: roundNumber,        // MongoDB schema uses roundId
        fightId,
        isWinner,
        date: fightDate
    };
    
    if (existingOpponent) {
        existingOpponent.totalFights += 1;
        if (isWinner) {
            existingOpponent.totalWins += 1;
        } else {
            existingOpponent.totalLosses += 1;
        }
        existingOpponent.winPercentage = (existingOpponent.totalWins / existingOpponent.totalFights) * 100;
        existingOpponent.details.push(newDetail);
        
        console.log(`   ‚úì Updated vs opponent: ${existingOpponent.totalWins}W-${existingOpponent.totalLosses}L`);
    } else {
        fighter.opponentsHistory.push({
            opponentId,
            totalFights: 1,
            totalWins: isWinner ? 1 : 0,
            totalLosses: isWinner ? 0 : 1,
            winPercentage: isWinner ? 100 : 0,
            details: [newDetail]
        });
        
        console.log(`   ‚ú® New opponent record: ${isWinner ? '1W-0L' : '0W-1L'}`);
    }
}

/**
 * ====================================================================================
 * STEP 7A: UPDATE FIGHTER DEBUT INFORMATION (IF FIRST FIGHT)
 * ====================================================================================
 * Sets debut information if this is the fighter's first ever fight
 */
async function updateFighterDebutInformation(
    fighter,
    competitionMetaId,
    seasonNumber,
    fightId,
    fightDate
) {
    console.log(`\nüé¨ Step 7A: Checking Debut Information for ${fighter.firstName} ${fighter.lastName}...`);
    
    const hasDebut = fighter.debutInformation && 
                     fighter.debutInformation.competitionId && 
                     fighter.debutInformation.fightId;
    
    if (!hasDebut) {
        fighter.debutInformation = {
            competitionId: competitionMetaId,
            season: seasonNumber,
            fightId,
            dateOfDebut: fightDate
        };
        console.log(`   ‚ú® First fight ever! Debut recorded`);
    } else {
        console.log(`   ‚è≠Ô∏è  Already has debut (${fighter.debutInformation.competitionId})`);
    }
}

/**
 * ====================================================================================
 * STEP 7B: UPDATE FIGHTER STREAKS
 * ====================================================================================
 * Manages win/loss streaks - creates, continues, or breaks streaks
 */
async function updateFighterStreaks(
    fighter,
    competitionMetaId,
    seasonNumber,
    divisionNumber,
    roundNumber,
    opponentId,
    isWinner
) {
    console.log(`\nüî• Step 7B: Updating Streaks for ${fighter.firstName} ${fighter.lastName}...`);
    
    const streaks = fighter.streaks || [];
    const activeStreak = streaks.find(s => s.active === true);
    const resultType = isWinner ? 'win' : 'lose';
    
    if (!activeStreak) {
        // No active streak - create new one
        fighter.streaks.push({
            competitionId: competitionMetaId,
            type: resultType,
            start: { season: seasonNumber, division: divisionNumber, round: roundNumber },
            end: { season: seasonNumber, division: divisionNumber, round: roundNumber },
            count: 1,
            active: true,
            opponents: [opponentId]
        });
        console.log(`   ‚ú® Created new ${resultType} streak (count: 1)`);
    } else if (activeStreak.type === resultType) {
        // Streak continues
        activeStreak.count += 1;
        activeStreak.end = { season: seasonNumber, division: divisionNumber, round: roundNumber };
        activeStreak.opponents.push(opponentId);
        console.log(`   üìà ${resultType} streak continues (count: ${activeStreak.count})`);
    } else {
        // Streak breaks
        activeStreak.active = false;
        console.log(`   üíî ${activeStreak.type} streak broken at ${activeStreak.count}`);
        
        // Create new streak
        fighter.streaks.push({
            competitionId: competitionMetaId,
            type: resultType,
            start: { season: seasonNumber, division: divisionNumber, round: roundNumber },
            end: { season: seasonNumber, division: divisionNumber, round: roundNumber },
            count: 1,
            active: true,
            opponents: [opponentId]
        });
        console.log(`   ‚ú® Started new ${resultType} streak (count: 1)`);
    }
}

/**
 * ====================================================================================
 * STEP 7C: UPDATE FIGHTER FIGHT STATS (AVERAGING)
 * ====================================================================================
 * Updates lifetime fight statistics using weighted averaging
 */
async function updateFighterFightStats(fighter, chatGPTStats) {
    console.log(`\nüìä Step 7C: Updating Fight Stats for ${fighter.firstName} ${fighter.lastName}...`);
    
    const currentStats = fighter.fightStats || {};
    const currentCount = currentStats.fightsCount || 0;
    const newCount = currentCount + 1;
    
    // Helper to calculate weighted average
    const avg = (currentValue, newValue) => {
        if (currentCount === 0) return newValue || 0;
        const curr = currentValue || 0;
        const newVal = newValue || 0;
        return ((curr * currentCount) + newVal) / newCount;
    };
    
    // Update finishing moves (array of unique strings)
    const currentFinishingMoves = currentStats.finishingMoves || [];
    const newFinishingMove = chatGPTStats.finishingMove;
    console.log(`   - Current finishing moves:`, currentFinishingMoves);
    console.log(`   - New finishing move:`, newFinishingMove);
    if (newFinishingMove && !currentFinishingMoves.includes(newFinishingMove)) {
        currentFinishingMoves.push(newFinishingMove);
        console.log(`   ‚úì Added finishing move: ${newFinishingMove}`);
    } else if (newFinishingMove) {
        console.log(`   ‚ÑπÔ∏è  Finishing move already exists: ${newFinishingMove}`);
    } else {
        console.log(`   ‚ÑπÔ∏è  No finishing move (loser)`)
    }
    console.log(`   - Updated finishing moves:`, currentFinishingMoves);
    
    // Build updated stats with averaging
    fighter.fightStats = {
        fightsCount: newCount,
        avgFightTime: avg(currentStats.avgFightTime, chatGPTStats.fightTime),
        finishingMoves: currentFinishingMoves,
        grappling: {
            accuracy: avg(currentStats.grappling?.accuracy, chatGPTStats.grappling?.accuracy),
            defence: avg(currentStats.grappling?.defence, chatGPTStats.grappling?.defence)
        },
        significantStrikes: {
            accuracy: avg(currentStats.significantStrikes?.accuracy, chatGPTStats.significantStrikes?.accuracy),
            attempted: avg(currentStats.significantStrikes?.attempted, chatGPTStats.significantStrikes?.attempted),
            defence: avg(currentStats.significantStrikes?.defence, chatGPTStats.significantStrikes?.defence),
            landed: avg(currentStats.significantStrikes?.landed, chatGPTStats.significantStrikes?.landed),
            landedPerMinute: avg(currentStats.significantStrikes?.landedPerMinute, chatGPTStats.significantStrikes?.landedPerMinute),
            positions: {
                clinching: avg(currentStats.significantStrikes?.positions?.clinching, chatGPTStats.significantStrikes?.positions?.clinching),
                ground: avg(currentStats.significantStrikes?.positions?.ground, chatGPTStats.significantStrikes?.positions?.ground),
                standing: avg(currentStats.significantStrikes?.positions?.standing, chatGPTStats.significantStrikes?.positions?.standing)
            }
        },
        strikeMap: {
            head: {
                absorb: avg(currentStats.strikeMap?.head?.absorb, chatGPTStats.strikeMap?.head?.absorb),
                strike: avg(currentStats.strikeMap?.head?.strike, chatGPTStats.strikeMap?.head?.strike)
            },
            torso: {
                absorb: avg(currentStats.strikeMap?.torso?.absorb, chatGPTStats.strikeMap?.torso?.absorb),
                strike: avg(currentStats.strikeMap?.torso?.strike, chatGPTStats.strikeMap?.torso?.strike)
            },
            leg: {
                absorb: avg(currentStats.strikeMap?.leg?.absorb, chatGPTStats.strikeMap?.leg?.absorb),
                strike: avg(currentStats.strikeMap?.leg?.strike, chatGPTStats.strikeMap?.leg?.strike)
            }
        },
        submissions: {
            attemptsPer15Mins: avg(currentStats.submissions?.attemptsPer15Mins, chatGPTStats.submissions?.attemptsPer15Mins),
            average: avg(currentStats.submissions?.average, chatGPTStats.submissions?.average)
        },
        takedowns: {
            accuracy: avg(currentStats.takedowns?.accuracy, chatGPTStats.takedowns?.accuracy),
            attempted: avg(currentStats.takedowns?.attempted, chatGPTStats.takedowns?.attempted),
            avgTakedownsLandedPerMin: avg(currentStats.takedowns?.avgTakedownsLandedPerMin, chatGPTStats.takedowns?.avgTakedownsLandedPerMin),
            defence: avg(currentStats.takedowns?.defence, chatGPTStats.takedowns?.defence),
            landed: avg(currentStats.takedowns?.landed, chatGPTStats.takedowns?.landed)
        }
    };
    
    console.log(`   ‚úì Stats updated (fightsCount: ${currentCount} ‚Üí ${newCount})`);
    if (newFinishingMove) {
        console.log(`   ‚úì Finishing move: ${newFinishingMove}`);
    }
}

/**
 * ====================================================================================
 * CALCULATE ROUND STANDINGS (LEAGUE ONLY)
 * ====================================================================================
 * Calculates standings for all fighters in a division after this fight
 */
async function calculateAndSaveRoundStandings(
    competition,
    fightIdentifier,
    divisionNumber,
    roundNumber,
    competitionType,
    session
) {
    // Skip for cup competitions
    if (competitionType === 'cup') {
        console.log(`\n‚è≠Ô∏è  Round Standings: Skipped (cup competition)`);
        return;
    }
    
    console.log(`\nüìä Calculating Round Standings for ${fightIdentifier}...`);
    
    const division = competition.leagueData.divisions.find(
        d => d.divisionNumber === divisionNumber
    );
    
    if (!division) {
        console.warn(`   ‚ö†Ô∏è  Division ${divisionNumber} not found`);
        return;
    }
    
    // Get all division fighters
    const divisionFighters = competition.seasonMeta.leagueDivisions.find(
        ld => ld.divisionNumber === divisionNumber
    )?.fighters || [];
    
    console.log(`   - Division fighters: ${divisionFighters.length}`);
    
    // Get all completed fights in this division
    const allFights = [];
    division.rounds.forEach(round => {
        round.fights.forEach(fight => {
            if (fight.fightStatus === 'completed' || fight.winner) {
                allFights.push(fight);
            }
        });
    });
    
    console.log(`   - Completed fights: ${allFights.length}`);
    
    // Calculate stats for each fighter
    const fighterStatsMap = new Map();
    divisionFighters.forEach(fighterId => {
        fighterStatsMap.set(fighterId.toString(), {
            fighterId,
            fightsCount: 0,
            wins: 0,
            points: 0,
            rank: 0,
            totalFightersCount: divisionFighters.length
        });
    });
    
    // Process all completed fights
    allFights.forEach(fight => {
        const f1Id = fight.fighter1.toString();
        const f2Id = fight.fighter2.toString();
        const winnerId = fight.winner?.toString();
        
        const f1Stats = fighterStatsMap.get(f1Id);
        const f2Stats = fighterStatsMap.get(f2Id);
        
        if (f1Stats) {
            f1Stats.fightsCount++;
            if (winnerId === f1Id) {
                f1Stats.wins++;
                f1Stats.points += POINTS_PER_WIN;
            }
        }
        
        if (f2Stats) {
            f2Stats.fightsCount++;
            if (winnerId === f2Id) {
                f2Stats.wins++;
                f2Stats.points += POINTS_PER_WIN;
            }
        }
    });
    
    // Sort standings with tiebreakers
    const standings = sortStandingsWithTiebreakers(
        Array.from(fighterStatsMap.values()),
        allFights
    );
    
    console.log(`   ‚úì Standings calculated - Top 3:`);
    standings.slice(0, 3).forEach((s, idx) => {
        const trophy = idx === 0 ? ' üèÜ' : '';
        console.log(`      ${s.rank}. Fighter ${s.fighterId.toString().substring(0, 8)}... - ${s.points} pts (${s.wins}W)${trophy}`);
    });
    
    // Save to RoundStandings collection
    console.log('   üìù Saving standings to database...');
    console.log('      - Competition Meta ID:', competition.competitionMetaId._id);
    console.log('      - Competition ID:', competition._id);
    console.log('      - Season Number:', competition.seasonMeta.seasonNumber);
    console.log('      - Division Number:', divisionNumber);
    console.log('      - Round Number:', roundNumber);
    console.log('      - Fight Identifier:', fightIdentifier);
    
    const savedStandings = await RoundStandings.findOneAndUpdate(
        {
            competitionId: competition.competitionMetaId._id,
            seasonNumber: competition.seasonMeta.seasonNumber,
            divisionNumber,
            roundNumber,
            fightId: fightIdentifier
        },
        {
            fightIdentifier,
            standings,
            createdAt: new Date(),
            updatedAt: new Date()
        },
        {
            upsert: true,
            new: true,
            session
        }
    );
    
    console.log(`   ‚úì Round standings saved to database (ID: ${savedStandings._id})`);
    console.log(`   ‚úì Saved ${standings.length} fighter standings`);
}

/**
 * Sort standings with head-to-head tiebreakers
 */
function sortStandingsWithTiebreakers(standings, completedFights) {
    // Group by points
    const pointsGroups = new Map();
    standings.forEach(s => {
        const group = pointsGroups.get(s.points) || [];
        group.push(s.fighterId.toString());
        pointsGroups.set(s.points, group);
    });
    
    const fighterRankings = new Map();
    let currentRank = 1;
    
    // Sort points descending
    const sortedPoints = Array.from(pointsGroups.keys()).sort((a, b) => b - a);
    
    sortedPoints.forEach(points => {
        const tiedFighters = pointsGroups.get(points);
        
        if (tiedFighters.length === 1) {
            fighterRankings.set(tiedFighters[0], currentRank);
            currentRank++;
        } else {
            // Calculate head-to-head
            const h2hPoints = new Map();
            tiedFighters.forEach(fid => h2hPoints.set(fid, 0));
            
            completedFights.forEach(fight => {
                const f1 = fight.fighter1.toString();
                const f2 = fight.fighter2.toString();
                const winner = fight.winner?.toString();
                
                if (tiedFighters.includes(f1) && tiedFighters.includes(f2) && winner) {
                    const current = h2hPoints.get(winner) || 0;
                    h2hPoints.set(winner, current + POINTS_PER_WIN);
                }
            });
            
            // Sort by h2h, then alphabetically
            const sortedTied = [...tiedFighters].sort((a, b) => {
                const h2hA = h2hPoints.get(a) || 0;
                const h2hB = h2hPoints.get(b) || 0;
                if (h2hA !== h2hB) return h2hB - h2hA;
                return a.localeCompare(b);
            });
            
            sortedTied.forEach(fid => {
                fighterRankings.set(fid, currentRank);
                currentRank++;
            });
        }
    });
    
    // Apply ranks
    standings.forEach(s => {
        s.rank = fighterRankings.get(s.fighterId.toString()) || 999;
    });
    
    return standings.sort((a, b) => a.rank - b.rank);
}

/**
 * ====================================================================================
 * CHECK SEASON COMPLETION
 * ====================================================================================
 * Determines if all fights in the final round of all divisions are complete
 */
function checkSeasonCompletion(competition) {
    console.log(`\nüîç Checking Season Completion...`);
    
    const isLeague = competition.leagueData !== null && competition.leagueData !== undefined;
    
    if (isLeague) {
        const divisions = competition.leagueData.divisions;
        let allComplete = true;
        
        divisions.forEach(division => {
            const lastRound = division.rounds.find(r => r.roundNumber === division.totalRounds);
            if (!lastRound) {
                allComplete = false;
                return;
            }
            
            const totalFights = lastRound.fights.length;
            const completedFights = lastRound.fights.filter(
                f => f.fightStatus === 'completed' || f.winner
            ).length;
            
            console.log(`   üìä Division ${division.divisionNumber}: Round ${division.totalRounds} - ${completedFights}/${totalFights} fights completed`);
            
            if (completedFights < totalFights) {
                allComplete = false;
            }
        });
        
        if (allComplete) {
            console.log(`   ‚úÖ SEASON COMPLETED! All divisions finished.`);
        } else {
            console.log(`   ‚è≥ Season still in progress...`);
        }
        
        return allComplete;
    } else {
        // Cup competition
        const fights = competition.cupData?.fights || [];
        const finalFights = fights.filter(f => f.fightIdentifier.includes('-R3-'));
        if (finalFights.length === 0) return false;
        
        const allFinalsComplete = finalFights.every(f => f.fightStatus === 'completed' || f.winner);
        console.log(`   ${allFinalsComplete ? '‚úÖ CUP SEASON COMPLETED!' : '‚è≥ Cup in progress...'}`);
        
        return allFinalsComplete;
    }
}

/**
 * ====================================================================================
 * UPDATE CURRENT ROUND FOR DIVISION (LEAGUE ONLY)
 * ====================================================================================
 * Updates the currentRound field to reflect the latest completed fight
 */
function updateDivisionCurrentRound(competition, divisionNumber, roundNumber, competitionType) {
    if (competitionType !== 'league') {
        console.log(`\n‚è≠Ô∏è  Current Round Update: Skipped (cup competition)`);
        return;
    }
    
    console.log(`\nüîÑ Updating Current Round for Division ${divisionNumber}...`);
    
    const division = competition.leagueData.divisions.find(
        d => d.divisionNumber === divisionNumber
    );
    
    if (!division) {
        console.warn(`   ‚ö†Ô∏è  Division ${divisionNumber} not found`);
        return;
    }
    
    // Find the round that was just completed
    const round = division.rounds?.find(r => r.roundNumber === roundNumber);
    
    if (!round) {
        console.warn(`   ‚ö†Ô∏è  Round ${roundNumber} not found in division`);
        return;
    }
    
    // Count total fights and completed fights in this round
    const totalFights = round.fights?.length || 0;
    const completedFights = round.fights?.filter(f => f.winner).length || 0;
    
    console.log(`   üìä Round ${roundNumber} Status: ${completedFights}/${totalFights} fights complete`);
    
    const oldCurrentRound = division.currentRound || 0;
    
    // Only update currentRound if ALL fights in this round are complete
    if (completedFights === totalFights && totalFights > 0) {
        // Check if this is the last round
        if (roundNumber >= division.totalRounds) {
            // All rounds complete - keep currentRound at totalRounds
            if (oldCurrentRound !== division.totalRounds) {
                division.currentRound = division.totalRounds;
                console.log(`   ‚úÖ Division Complete! All ${division.totalRounds} rounds finished.`);
            } else {
                console.log(`   ‚úÖ Division already marked complete`);
            }
        } else {
            // Move to next round
            const newCurrentRound = roundNumber + 1;
            if (newCurrentRound > oldCurrentRound) {
                division.currentRound = newCurrentRound;
                console.log(`   ‚úì All fights in Round ${roundNumber} complete! Updated currentRound: ${oldCurrentRound} ‚Üí ${newCurrentRound}`);
            } else {
                console.log(`   ‚ÑπÔ∏è  currentRound unchanged: ${oldCurrentRound}`);
            }
        }
    } else {
        console.log(`   ‚ÑπÔ∏è  currentRound unchanged: ${oldCurrentRound} (Round ${roundNumber} still in progress)`);
    }
}

/**
 * ====================================================================================
 * HANDLE CUP BRACKET PROGRESSION
 * ====================================================================================
 * Advances winners to next round or marks champion for cup competitions
 */
async function handleCupBracketProgression(
    competition,
    fightIdentifier,
    winnerId,
    competitionType,
    session
) {
    if (competitionType !== 'cup') {
        console.log(`\n‚è≠Ô∏è  Cup Progression: Skipped (league competition)`);
        return;
    }
    
    console.log(`\nüèÜ Processing Cup Bracket Progression...`);
    console.log(`   Fight: ${fightIdentifier}`);
    console.log(`   Winner: ${winnerId.toString().substring(0, 8)}...`);
    
    // Parse fight identifier
    const parts = fightIdentifier.split('-');
    const roundNumber = parseInt(parts[2].substring(1));
    const fightNumber = parseInt(parts[3].substring(1));
    const knockoutRounds = competition.config?.cupConfiguration?.knockoutRounds || 3;
    
    console.log(`   üìä Round ${roundNumber}, Fight ${fightNumber}`);
    
    // Check if this is the final
    if (roundNumber === knockoutRounds) {
        console.log(`   üéâ FINAL FIGHT! Updating season winner...`);
        competition.seasonMeta.winners = [winnerId];
        competition.isActive = false;
        competition.seasonMeta.endDate = new Date();
        
        // Update champion's titles
        await updateChampionTitle(winnerId, competition.competitionMetaId, competition._id, competition.seasonMeta.seasonNumber, session);
        
        return;
    }
    
    // Determine next round fight
    const nextRoundNumber = roundNumber + 1;
    const nextFightNumber = Math.ceil(fightNumber / 2);
    const isFirstFighterSlot = fightNumber % 2 === 1;
    const nextFightIdentifier = `${parts[0]}-S${parts[1].substring(1)}-R${nextRoundNumber}-F${nextFightNumber}`;
    
    console.log(`   ‚û°Ô∏è  Winner advances to: ${nextFightIdentifier} as ${isFirstFighterSlot ? 'Fighter 1' : 'Fighter 2'}`);
    
    // Find or create next fight
    const existingFight = competition.cupData.fights.find(f => f.fightIdentifier === nextFightIdentifier);
    
    if (existingFight) {
        if (isFirstFighterSlot) {
            existingFight.fighter1 = winnerId;
        } else {
            existingFight.fighter2 = winnerId;
        }
        console.log(`   ‚úì Updated existing fight`);
    } else {
        competition.cupData.fights.push({
            fighter1: isFirstFighterSlot ? winnerId : null,
            fighter2: isFirstFighterSlot ? null : winnerId,
            winner: null,
            fightIdentifier: nextFightIdentifier,
            date: null,
            userDescription: null,
            genAIDescription: null,
            isSimulated: false,
            fighterStats: [],
            fightStatus: 'scheduled'
        });
        console.log(`   ‚ú® Created new fight for next round`);
    }
}

/**
 * Update champion's title count
 */
async function updateChampionTitle(championId, competitionMetaId, competitionSeasonId, seasonNumber, session) {
    console.log(`\nüèÜ Updating Champion Title...`);
    
    const champion = await Fighter.findById(championId).session(session);
    if (!champion) {
        console.error(`   ‚ùå Champion not found: ${championId}`);
        return;
    }
    
    const compHistory = champion.competitionHistory.find(
        ch => ch.competitionId.toString() === competitionMetaId.toString()
    );
    
    if (!compHistory) {
        console.error(`   ‚ùå Competition history not found`);
        return;
    }
    
    if (!compHistory.titles) {
        compHistory.titles = { totalTitles: 0, details: [] };
    }
    
    compHistory.titles.totalTitles += 1;
    compHistory.titles.details.push({
        competitionSeasonId,
        seasonNumber
    });
    
    await champion.save({ session });
    
    console.log(`   ‚úì ${champion.firstName} ${champion.lastName} now has ${compHistory.titles.totalTitles} title(s)`);
}

/**
 * ====================================================================================
 * CHECK AND CREATE IC SEASON (25% LEAGUE COMPLETION)
 * ====================================================================================
 * Creates Invicta Cup season when league reaches exactly 25% completion
 */
async function checkAndCreateICSeasonIfNeeded(competition, session) {
    console.log(`\nüîç Checking if IC Season should be created...`);
    
    // Calculate completion percentage
    const divisions = competition.leagueData.divisions;
    let totalFights = 0;
    let completedFights = 0;
    
    divisions.forEach(division => {
        division.rounds.forEach(round => {
            const fights = round.fights || [];
            totalFights += fights.length;
            completedFights += fights.filter(f => f.fightStatus === 'completed' || f.winner).length;
        });
    });
    
    const completionPercentage = totalFights > 0 ? (completedFights / totalFights) * 100 : 0;
    console.log(`   üìä Completion: ${completedFights}/${totalFights} fights (${completionPercentage.toFixed(2)}%)`);
    
    // Check if exactly at 25% (with small tolerance for floating point)
    if (Math.abs(completionPercentage - 25) > 0.5) {
        if (completionPercentage > 25) {
            console.log('   ‚è≠Ô∏è  Skipping: Already past 25% threshold');
        } else {
            console.log('   ‚è≥ Not yet at 25% threshold');
        }
        return;
    }
    
    console.log('‚úÖ Exactly at 25% completion! Creating IC season...');
    
    try {
        // 1. Query IC competition meta
        const icMeta = await CompetitionMeta.findOne({
            competitionName: 'Invicta Cup',
            type: 'cup'
        }).session(session);
        
        if (!icMeta) {
            console.error('   ‚ùå Error: IC competition meta not found');
            return;
        }
        
        console.log(`   ‚úì Found IC meta: ${icMeta._id}`);
        
        // 2. Check if IC season already exists for this league season
        const existingICSeasons = await Competition.find({
            'linkedLeagueSeason.competitionId': competition._id,
            'linkedLeagueSeason.seasonNumber': competition.seasonMeta.seasonNumber
        }).session(session);
        
        if (existingICSeasons.length > 0) {
            console.log('   ‚è≠Ô∏è  Skipping: IC season already exists for this league season');
            return;
        }
        
        // 3. Find previous IC champion
        const previousICSeason = await Competition.findOne({
            competitionMetaId: icMeta._id
        })
        .sort({ 'seasonMeta.seasonNumber': -1 })
        .limit(1)
        .session(session);
        
        const previousChampion = previousICSeason?.seasonMeta?.winners?.[0];
        const newICSeasonNumber = (previousICSeason?.seasonMeta?.seasonNumber || 0) + 1;
        
        console.log(`   üëë Previous IC champion: ${previousChampion ? previousChampion.toString().substring(0, 8) + '...' : 'None'}`);
        console.log(`   üìä New IC season number: ${newICSeasonNumber}`);
        
        // 4. Get all fighters from current league season
        const allLeagueFighters = [];
        const divisionFightersMap = new Map();
        
        competition.seasonMeta.leagueDivisions.forEach(division => {
            const fighters = division.fighters || [];
            divisionFightersMap.set(division.divisionNumber, fighters);
            allLeagueFighters.push(...fighters.map(f => f.toString()));
        });
        
        console.log(`   üë• Total league fighters: ${allLeagueFighters.length}`);
        
        // 5. Select 8 fighters (1 champion + 7 from league)
        const selectedFighters = [];
        
        // Add previous champion if exists and is in current league
        if (previousChampion && allLeagueFighters.includes(previousChampion.toString())) {
            selectedFighters.push(previousChampion);
            console.log(`   ‚úì Champion ${previousChampion.toString().substring(0, 8)}... included`);
        }
        
        // Remove champion from available pool
        const availableFighters = allLeagueFighters.filter(
            id => !selectedFighters.some(sf => sf.toString() === id)
        );
        
        if (availableFighters.length < (8 - selectedFighters.length)) {
            console.error(`   ‚ùå Error: Not enough fighters (need ${8 - selectedFighters.length}, have ${availableFighters.length})`);
            return;
        }
        
        // Ensure at least 1 fighter from each division
        const fightersToSelect = new Set();
        divisionFightersMap.forEach((fighters, divisionNumber) => {
            const divisionAvailable = fighters.filter(
                f => !selectedFighters.some(sf => sf.toString() === f.toString())
            );
            if (divisionAvailable.length > 0) {
                const randomIndex = Math.floor(Math.random() * divisionAvailable.length);
                const selected = divisionAvailable[randomIndex];
                fightersToSelect.add(selected.toString());
                console.log(`   ‚úì Division ${divisionNumber}: Selected ${selected.toString().substring(0, 8)}...`);
            }
        });
        
        // Fill remaining spots randomly
        const remainingFighters = availableFighters.filter(id => !fightersToSelect.has(id));
        const needMoreFighters = (8 - selectedFighters.length) - fightersToSelect.size;
        
        if (needMoreFighters > 0) {
            const shuffled = remainingFighters.sort(() => Math.random() - 0.5);
            for (let i = 0; i < Math.min(needMoreFighters, shuffled.length); i++) {
                fightersToSelect.add(shuffled[i]);
                console.log(`   ‚úì Random: Selected ${shuffled[i].substring(0, 8)}...`);
            }
        }
        
        selectedFighters.push(...Array.from(fightersToSelect).slice(0, 8 - selectedFighters.length));
        
        if (selectedFighters.length !== 8) {
            console.error(`   ‚ùå Error: Could not select exactly 8 fighters (got ${selectedFighters.length})`);
            return;
        }
        
        console.log(`   ‚úÖ Selected 8 fighters for IC season`);
        
        // 6. Create random pairings for Round 1 (4 fights)
        const shuffledFighters = [...selectedFighters].sort(() => Math.random() - 0.5);
        const round1Fights = [];
        
        for (let i = 0; i < 4; i++) {
            const fighter1 = shuffledFighters[i * 2];
            const fighter2 = shuffledFighters[i * 2 + 1];
            const fightIdentifier = `IC-S${newICSeasonNumber}-R1-F${i + 1}`;
            
            round1Fights.push({
                fighter1,
                fighter2,
                winner: null,
                fightIdentifier,
                date: null,
                userDescription: null,
                genAIDescription: null,
                isSimulated: false,
                fighterStats: [],
                fightStatus: 'scheduled'
            });
            
            console.log(`   ü•ä Fight ${i + 1}: ${fighter1.toString().substring(0, 8)}... vs ${fighter2.toString().substring(0, 8)}...`);
        }
        
        // 7. Create IC season document
        const newICSeason = new Competition({
            competitionMetaId: icMeta._id,
            isActive: true,
            seasonMeta: {
                seasonNumber: newICSeasonNumber,
                startDate: new Date(),
                endDate: null,
                winners: [],
                leagueDivisions: null,
                cupParticipants: {
                    fighters: selectedFighters
                }
            },
            leagueData: null,
            cupData: {
                fights: round1Fights,
                currentStage: 'Quarter-finals',
                rounds: null
            },
            config: {
                leagueConfiguration: null,
                cupConfiguration: {
                    knockoutRounds: 3,
                    numberOfFighters: 8,
                    perFightFeeInEur: 10000,
                    winningFeeInEur: 100000,
                    stages: ['Quarter-finals', 'Semi-finals', 'Finals']
                }
            },
            linkedLeagueSeason: {
                competitionId: competition._id,
                seasonNumber: competition.seasonMeta.seasonNumber
            }
        });
        
        await newICSeason.save({ session });
        
        console.log('\n‚ú® IC Season created successfully!');
        console.log(`   üèÜ Season: IC S${newICSeasonNumber}`);
        console.log(`   üë• Participants: 8 fighters`);
        console.log(`   ü•ä Round 1 Fights: 4 (all scheduled)`);
        console.log(`   üîó Linked to: League ${competition._id.toString().substring(0, 8)}... S${competition.seasonMeta.seasonNumber}`);
        console.log(`   üíæ Saved to MongoDB: ${newICSeason._id}`);
        
    } catch (error) {
        console.error('   ‚ùå Error creating IC season:', error.message);
        throw error; // Will trigger transaction rollback
    }
}

/**
 * ====================================================================================
 * CHECK AND CREATE CC SEASON (100% LEAGUE COMPLETION)
 * ====================================================================================
 * Creates Champions Cup season when league is 100% complete
 */
async function checkAndCreateCCSeasonIfNeeded(competition, session) {
    console.log(`\nüèÜ Checking if CC Season should be created...`);
    
    try {
        // 1. Query CC competition meta
        const ccMeta = await CompetitionMeta.findOne({
            competitionName: 'Champions Cup',
            type: 'cup'
        }).session(session);
        
        if (!ccMeta) {
            console.error('   ‚ùå Error: CC competition meta not found');
            return;
        }
        
        console.log(`   ‚úì Found CC meta: ${ccMeta._id}`);
        
        // 2. Check if CC season already exists for this league season
        const existingCCSeasons = await Competition.find({
            'linkedLeagueSeason.competitionId': competition._id,
            'linkedLeagueSeason.seasonNumber': competition.seasonMeta.seasonNumber
        }).session(session);
        
        if (existingCCSeasons.length > 0) {
            console.log('   ‚è≠Ô∏è  Skipping: IC season already exists for this league season');
            return;
        }
        
        // 3. Find latest CC season number
        const latestCCSeason = await Competition.findOne({
            competitionMetaId: ccMeta._id
        })
        .sort({ 'seasonMeta.seasonNumber': -1 })
        .limit(1)
        .session(session);
        
        const newCCSeasonNumber = (latestCCSeason?.seasonMeta?.seasonNumber || 0) + 1;
        console.log(`   üìä New CC season number: ${newCCSeasonNumber}`);
        
        // 4. Query final standings for all 3 divisions
        const selectedFighters = [];
        
        for (let divisionNumber = 1; divisionNumber <= 3; divisionNumber++) {
            const finalStandings = await RoundStandings.findOne({
                competitionId: competition._id,
                seasonNumber: competition.seasonMeta.seasonNumber,
                divisionNumber: divisionNumber
            })
            .sort({ roundNumber: -1 })
            .limit(1)
            .session(session);
            
            if (!finalStandings || !finalStandings.standings) {
                console.error(`   ‚ùå Error: No standings found for Division ${divisionNumber}`);
                return;
            }
            
            // Sort by rank (should already be sorted, but ensuring)
            const sortedStandings = finalStandings.standings.sort((a, b) => a.rank - b.rank);
            
            // Select top fighters based on division
            const topCount = divisionNumber === 3 ? 2 : 3; // D1: 3, D2: 3, D3: 2
            const topFighters = sortedStandings.slice(0, topCount).map(s => s.fighterId);
            
            if (topFighters.length < topCount) {
                console.error(`   ‚ùå Error: Division ${divisionNumber} doesn't have ${topCount} fighters`);
                return;
            }
            
            selectedFighters.push(...topFighters);
            
            const emoji = divisionNumber === 1 ? 'ü•á' : divisionNumber === 2 ? 'ü•à' : 'ü•â';
            console.log(`   ${emoji} Division ${divisionNumber} - Top ${topCount}: ${topFighters.map(id => id.toString().substring(0, 8) + '...').join(', ')}`);
        }
        
        if (selectedFighters.length !== 8) {
            console.error(`   ‚ùå Error: Could not select exactly 8 fighters (got ${selectedFighters.length})`);
            return;
        }
        
        console.log(`   ‚úÖ Selected 8 fighters for CC season`);
        
        // 5. Create random pairings for Round 1 (4 fights)
        const shuffledFighters = [...selectedFighters].sort(() => Math.random() - 0.5);
        const round1Fights = [];
        
        for (let i = 0; i < 4; i++) {
            const fighter1 = shuffledFighters[i * 2];
            const fighter2 = shuffledFighters[i * 2 + 1];
            const fightIdentifier = `CC-S${newCCSeasonNumber}-R1-F${i + 1}`;
            
            round1Fights.push({
                fighter1,
                fighter2,
                winner: null,
                fightIdentifier,
                date: null,
                userDescription: null,
                genAIDescription: null,
                isSimulated: false,
                fighterStats: [],
                fightStatus: 'scheduled'
            });
            
            console.log(`   ü•ä Fight ${i + 1}: ${fighter1.toString().substring(0, 8)}... vs ${fighter2.toString().substring(0, 8)}...`);
        }
        
        // 6. Create CC season document
        const newCCSeason = new Competition({
            competitionMetaId: ccMeta._id,
            isActive: true,
            seasonMeta: {
                seasonNumber: newCCSeasonNumber,
                startDate: new Date(),
                endDate: null,
                winners: [],
                leagueDivisions: null,
                cupParticipants: {
                    fighters: selectedFighters
                }
            },
            leagueData: null,
            cupData: {
                fights: round1Fights,
                currentStage: 'Quarter-finals',
                rounds: null
            },
            config: {
                leagueConfiguration: null,
                cupConfiguration: {
                    knockoutRounds: 3,
                    numberOfFighters: 8,
                    perFightFeeInEur: 15000,
                    winningFeeInEur: 150000,
                    stages: ['Quarter-finals', 'Semi-finals', 'Finals']
                }
            },
            linkedLeagueSeason: {
                competitionId: competition._id,
                seasonNumber: competition.seasonMeta.seasonNumber
            }
        });
        
        await newCCSeason.save({ session });
        
        console.log('\n‚ú® CC Season created successfully!');
        console.log(`   üèÜ Season: CC S${newCCSeasonNumber}`);
        console.log(`   üë• Participants: 8 fighters (top-ranked from league)`);
        console.log(`   ü•ä Round 1 Fights: 4 (all scheduled)`);
        console.log(`   üîó Linked to: League ${competition._id.toString().substring(0, 8)}... S${competition.seasonMeta.seasonNumber}`);
        console.log(`   üíæ Saved to MongoDB: ${newCCSeason._id}`);
        
    } catch (error) {
        console.error('   ‚ùå Error creating CC season:', error.message);
        throw error; // Will trigger transaction rollback
    }
}

/**
 * ====================================================================================
 * MAIN FUNCTION: APPLY COMPLETE FIGHT RESULT
 * ====================================================================================
 * Orchestrates all 8 steps in a single MongoDB transaction
 */
export async function applyFightResult(
    competitionId,
    seasonNumber,
    divisionNumber,
    roundNumber,
    fightIndex,
    fighter1Id,
    fighter2Id,
    generatedResult,
    isSimulated,
    userDescription,
    fightDate
) {
    console.log('\nüöÄ ========================================');
    console.log('   APPLYING FIGHT RESULT');
    console.log('========================================');
    
    const dbStartTime = Date.now();
    const session = await Fighter.startSession();
    session.startTransaction();
    
    try {
        // Fetch competition
        const competition = await Competition.findById(competitionId)
            .populate('competitionMetaId')
            .session(session);
        
        if (!competition) {
            throw new Error('Competition not found');
        }
        
        const competitionType = competition.leagueData ? 'league' : 'cup';
        console.log(`üìä Competition Type: ${competitionType.toUpperCase()}`);
        
        // Find the fight
        let fight;
        if (competitionType === 'league') {
            const division = competition.leagueData.divisions.find(d => d.divisionNumber === divisionNumber);
            if (!division) throw new Error(`Division ${divisionNumber} not found`);
            
            const round = division.rounds.find(r => r.roundNumber === roundNumber);
            if (!round) throw new Error(`Round ${roundNumber} not found`);
            
            fight = round.fights[fightIndex];
        } else {
            fight = competition.cupData.fights[fightIndex];
        }
        
        if (!fight) throw new Error(`Fight at index ${fightIndex} not found`);
        
        const fightIdentifier = fight.fightIdentifier;
        console.log(`ü•ä Fight: ${fightIdentifier}`);
        console.log(`üë§ Fighter 1: ${fighter1Id.toString().substring(0, 8)}...`);
        console.log(`üë§ Fighter 2: ${fighter2Id.toString().substring(0, 8)}...`);
        console.log(`üèÜ Winner: ${generatedResult.winnerId.toString().substring(0, 8)}...`);
        
        // Fetch fighters
        const [fighter1, fighter2] = await Promise.all([
            Fighter.findById(fighter1Id).session(session),
            Fighter.findById(fighter2Id).session(session)
        ]);
        
        if (!fighter1 || !fighter2) {
            throw new Error('One or both fighters not found');
        }
        
        const fighter1IsWinner = generatedResult.winnerId.toString() === fighter1Id.toString();
        const fighter2IsWinner = !fighter1IsWinner;
        
        // STEP 1-2: Update fight document
        await updateCompetitionFight(competition, fight, generatedResult, isSimulated, userDescription, fightDate);
        
        // Get fighter stats from generated result
        const fighter1Stats = generatedResult.fighterStats.find(fs => fs.fighterId.toString() === fighter1Id.toString())?.stats;
        const fighter2Stats = generatedResult.fighterStats.find(fs => fs.fighterId.toString() === fighter2Id.toString())?.stats;
        
        if (!fighter1Stats || !fighter2Stats) {
            throw new Error('Fighter stats not found in generated result');
        }
        
        // STEPS 3-7C: Update Fighter 1
        console.log(`\n${'='.repeat(70)}`);
        console.log(`UPDATING FIGHTER 1: ${fighter1.firstName} ${fighter1.lastName}`);
        console.log(`${'='.repeat(70)}`);
        
        await updateFighterCompetitionHistory(fighter1, competition.competitionMetaId._id, fighter1IsWinner);
        await updateFighterSeasonDetails(fighter1, competition.competitionMetaId._id, seasonNumber, divisionNumber, fighter1IsWinner, competitionType);
        await updateFighterOpponentsHistory(fighter1, fighter2Id, competition.competitionMetaId._id, seasonNumber, divisionNumber, roundNumber, fight._id, fighter1IsWinner, fight.date);
        await updateFighterDebutInformation(fighter1, competition.competitionMetaId._id, seasonNumber, fight._id, fight.date);
        await updateFighterStreaks(fighter1, competition.competitionMetaId._id, seasonNumber, divisionNumber, roundNumber, fighter2Id, fighter1IsWinner);
        await updateFighterFightStats(fighter1, fighter1Stats);
        
        // STEPS 3-7C: Update Fighter 2
        console.log(`\n${'='.repeat(70)}`);
        console.log(`UPDATING FIGHTER 2: ${fighter2.firstName} ${fighter2.lastName}`);
        console.log(`${'='.repeat(70)}`);
        
        await updateFighterCompetitionHistory(fighter2, competition.competitionMetaId._id, fighter2IsWinner);
        await updateFighterSeasonDetails(fighter2, competition.competitionMetaId._id, seasonNumber, divisionNumber, fighter2IsWinner, competitionType);
        await updateFighterOpponentsHistory(fighter2, fighter1Id, competition.competitionMetaId._id, seasonNumber, divisionNumber, roundNumber, fight._id, fighter2IsWinner, fight.date);
        await updateFighterDebutInformation(fighter2, competition.competitionMetaId._id, seasonNumber, fight._id, fight.date);
        await updateFighterStreaks(fighter2, competition.competitionMetaId._id, seasonNumber, divisionNumber, roundNumber, fighter1Id, fighter2IsWinner);
        await updateFighterFightStats(fighter2, fighter2Stats);
        
        // Calculate and save round standings (league only)
        console.log(`\nüéØ About to calculate standings - Competition Type: ${competitionType}, Division: ${divisionNumber}, Round: ${roundNumber}`);
        await calculateAndSaveRoundStandings(competition, fightIdentifier, divisionNumber, roundNumber, competitionType, session);
        
        // Update division currentRound (league only)
        updateDivisionCurrentRound(competition, divisionNumber, roundNumber, competitionType);
        
        // Handle cup bracket progression (cup only)
        await handleCupBracketProgression(competition, fightIdentifier, generatedResult.winnerId, competitionType, session);
        
        // Check season completion
        const isSeasonComplete = checkSeasonCompletion(competition);
        if (isSeasonComplete) {
            competition.isActive = false;
            competition.seasonMeta.endDate = new Date();
            console.log(`\nüèÅ Season marked as complete`);
            
            // Create CC season at 100% completion (league only)
            if (competitionType === 'league') {
                await checkAndCreateCCSeasonIfNeeded(competition, session);
            }
        }
        
        // Check for IC season creation at 25% completion (league only)
        if (competitionType === 'league') {
            await checkAndCreateICSeasonIfNeeded(competition, session);
        }
        
        // Check if this is the first fight of the season
        const allFights = competitionType === 'league' 
            ? competition.leagueData.divisions.flatMap(d => d.rounds.flatMap(r => r.fights))
            : competition.cupData.fights;
        
        const isFirstFight = allFights.filter(f => f.fightStatus === 'completed' || f.winner).length === 1;
        
        if (isFirstFight && !competition.seasonMeta.createdAt) {
            competition.seasonMeta.createdAt = new Date();
            console.log(`\nüéâ First fight of the season! Setting createdAt timestamp`);
        }
        
        // Save all changes
        await competition.save({ session });
        await fighter1.save({ session });
        await fighter2.save({ session });
        
        // Commit transaction
        await session.commitTransaction();
        
        const dbDuration = Date.now() - dbStartTime;
        console.log(`‚è±Ô∏è  Database operations completed in ${dbDuration}ms (${(dbDuration / 1000).toFixed(2)}s)`);
        
        console.log('\n‚úÖ ========================================');
        console.log('   ALL UPDATES COMMITTED SUCCESSFULLY');
        console.log('========================================\n');
        
        return {
            success: true,
            fightIdentifier,
            winner: generatedResult.winnerId,
            isSeasonComplete
        };
        
    } catch (error) {
        // Rollback on error
        await session.abortTransaction();
        console.error('\n‚ùå ========================================');
        console.error('   TRANSACTION ROLLED BACK');
        console.error('========================================');
        console.error('Error:', error);
        throw error;
    } finally {
        session.endSession();
    }
}

