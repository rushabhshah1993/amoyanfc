/**
 * Fight Result Service - Backend Implementation
 * 
 * This service handles ALL MongoDB updates after a fight result is generated by OpenAI.
 * It follows the exact same 8-step process as the frontend prepareFightResultPayload
 * to ensure data integrity and prevent corruption.
 * 
 * CRITICAL: All updates must succeed or ALL must rollback (transaction required)
 * 
 * @module services/fight-result.service
 */

import { Fighter } from '../models/fighter.model.js';
import { Competition } from '../models/competition.model.js';
import { CompetitionMeta } from '../models/competition-meta.model.js';
import { RoundStandings } from '../models/round-standings.model.js';
import { autoTriggerGlobalRankingIfNeeded } from '../resolvers/global-ranking-trigger.resolver.js';

const POINTS_PER_WIN = 3;

/**
 * ====================================================================================
 * STEP 1-2: UPDATE COMPETITION FIGHT DOCUMENT
 * ====================================================================================
 * Updates the fight with winner, stats, date, descriptions
 */
async function updateCompetitionFight(
    competition,
    fight,
    generatedResult,
    isSimulated,
    userDescription,
    fightDate
) {
    console.log('\nüìù Step 1-2: Updating Competition Fight Document...');
    
    console.log('üìä Generated Result Object:');
    console.log('   - winnerId:', generatedResult.winnerId);
    console.log('   - genAIDescription:', generatedResult.genAIDescription ? `${generatedResult.genAIDescription.substring(0, 80)}...` : 'MISSING');
    console.log('   - fighterStats:', generatedResult.fighterStats?.length, 'fighters');
    if (generatedResult.fighterStats) {
        generatedResult.fighterStats.forEach((fs, idx) => {
            console.log(`   - Fighter ${idx + 1}: finishingMove = ${fs.stats?.finishingMove || 'null'}`);
        });
    }
    
    fight.winner = generatedResult.winnerId;
    fight.genAIDescription = generatedResult.genAIDescription;
    fight.isSimulated = isSimulated;
    fight.fighterStats = generatedResult.fighterStats;
    fight.fightStatus = 'completed';
    
    if (!isSimulated && userDescription) {
        fight.userDescription = userDescription;
    }
    
    if (fightDate) {
        fight.date = fightDate;
    } else if (!fight.date) {
        fight.date = new Date();
    }
    
    console.log(`\n   ‚úì Fight ${fight.fightIdentifier} updated`);
    console.log(`   ‚úì Winner: ${fight.winner}`);
    console.log(`   ‚úì Date: ${fight.date}`);
    console.log(`   ‚úì AI Description: ${fight.genAIDescription ? 'Saved (' + fight.genAIDescription.length + ' chars)' : 'MISSING'}`);
    console.log(`   ‚úì Fighter Stats: ${fight.fighterStats?.length || 0} fighters`);
    if (fight.fighterStats) {
        fight.fighterStats.forEach((fs, idx) => {
            console.log(`      - Fighter ${idx + 1}: finishingMove = ${fs.stats?.finishingMove || 'null'}`);
        });
    }
}

/**
 * ====================================================================================
 * STEP 3: UPDATE FIGHTER COMPETITION HISTORY
 * ====================================================================================
 * Updates totalFights, totalWins, totalLosses, winPercentage for this competition
 */
async function updateFighterCompetitionHistory(fighter, competitionMetaId, isWinner) {
    console.log(`\nüìä Step 3: Updating Competition History for ${fighter.firstName} ${fighter.lastName}...`);
    
    const competitionHistory = fighter.competitionHistory || [];
    const existingComp = competitionHistory.find(
        ch => ch.competitionId.toString() === competitionMetaId.toString()
    );
    
    if (existingComp) {
        existingComp.totalFights += 1;
        if (isWinner) {
            existingComp.totalWins += 1;
        } else {
            existingComp.totalLosses += 1;
        }
        existingComp.winPercentage = (existingComp.totalWins / existingComp.totalFights) * 100;
        
        console.log(`   ‚úì Updated existing: ${existingComp.totalWins}W-${existingComp.totalLosses}L (${existingComp.winPercentage.toFixed(2)}%)`);
    } else {
        // Create new competition entry
        fighter.competitionHistory.push({
            competitionId: competitionMetaId,
            totalFights: 1,
            totalWins: isWinner ? 1 : 0,
            totalLosses: isWinner ? 0 : 1,
            winPercentage: isWinner ? 100 : 0,
            numberOfSeasonAppearances: 1,
            titles: { totalTitles: 0, details: [] },
            seasonDetails: []
        });
        
        console.log(`   ‚ú® Created new competition history: ${isWinner ? '1W-0L' : '0W-1L'}`);
    }
}

/**
 * ====================================================================================
 * STEP 4: UPDATE FIGHTER SEASON DETAILS
 * ====================================================================================
 * Updates fights, wins, losses, points, winPercentage for this season
 * For leagues: tracks division and points
 * For cups: tracks finalCupPosition instead of division/points
 */
async function updateFighterSeasonDetails(
    fighter,
    competitionMetaId,
    seasonNumber,
    divisionNumber,
    isWinner,
    competitionType,
    fightIdentifier = null
) {
    console.log(`\nüìà Step 4: Updating Season Details for ${fighter.firstName} ${fighter.lastName}...`);
    
    const competitionHistory = fighter.competitionHistory.find(
        ch => ch.competitionId.toString() === competitionMetaId.toString()
    );
    
    if (!competitionHistory) {
        console.error('   ‚ùå Competition history not found - this should not happen!');
        return;
    }
    
    const seasonDetails = competitionHistory.seasonDetails || [];
    
    if (competitionType === 'cup') {
        // For cup competitions, find by season only (no division)
        let existingSeason = seasonDetails.find(
            sd => sd.seasonNumber === seasonNumber && sd.divisionNumber === null
        );
        
        // Determine final cup position from fight identifier
        let finalCupPosition = 'Round 1'; // Default
        if (fightIdentifier) {
            if (fightIdentifier.includes('-FN')) {
                finalCupPosition = 'Finals';
            } else if (fightIdentifier.includes('-SF')) {
                finalCupPosition = 'Semifinals';
            } else if (fightIdentifier.match(/-R(\d+)-/)) {
                const roundMatch = fightIdentifier.match(/-R(\d+)-/);
                finalCupPosition = `Round ${roundMatch[1]}`;
            }
        }
        
        if (existingSeason) {
            existingSeason.fights += 1;
            if (isWinner) {
                existingSeason.wins += 1;
            } else {
                existingSeason.losses += 1;
            }
            existingSeason.winPercentage = (existingSeason.wins / existingSeason.fights) * 100;
            // Update finalCupPosition to the furthest round reached
            existingSeason.finalCupPosition = finalCupPosition;
            
            console.log(`   ‚úì Updated S${seasonNumber} (Cup): ${existingSeason.wins}W-${existingSeason.losses}L, ${finalCupPosition}`);
        } else {
            // First fight in this season - increment numberOfSeasonAppearances
            competitionHistory.numberOfSeasonAppearances = (competitionHistory.numberOfSeasonAppearances || 0) + 1;
            
            competitionHistory.seasonDetails.push({
                seasonNumber,
                divisionNumber: null,
                fights: 1,
                wins: isWinner ? 1 : 0,
                losses: isWinner ? 0 : 1,
                points: null,
                winPercentage: isWinner ? 100 : 0,
                finalCupPosition
            });
            
            console.log(`   ‚ú® Created new season details: S${seasonNumber} (Cup), ${finalCupPosition}`);
            console.log(`   üìä Total season appearances: ${competitionHistory.numberOfSeasonAppearances}`);
        }
    } else {
        // For league competitions, find by season AND division
        let existingSeason = seasonDetails.find(
            sd => sd.seasonNumber === seasonNumber && sd.divisionNumber === divisionNumber
        );
        
        if (existingSeason) {
            existingSeason.fights += 1;
            if (isWinner) {
                existingSeason.wins += 1;
                existingSeason.points += POINTS_PER_WIN;
            } else {
                existingSeason.losses += 1;
            }
            existingSeason.winPercentage = (existingSeason.wins / existingSeason.fights) * 100;
            
            console.log(`   ‚úì Updated S${seasonNumber} D${divisionNumber}: ${existingSeason.wins}W-${existingSeason.losses}L, ${existingSeason.points} pts`);
        } else {
            // First fight in this season/division - increment numberOfSeasonAppearances
            competitionHistory.numberOfSeasonAppearances = (competitionHistory.numberOfSeasonAppearances || 0) + 1;
            
            competitionHistory.seasonDetails.push({
                seasonNumber,
                divisionNumber,
                fights: 1,
                wins: isWinner ? 1 : 0,
                losses: isWinner ? 0 : 1,
                points: isWinner ? POINTS_PER_WIN : 0,
                winPercentage: isWinner ? 100 : 0
            });
            
            console.log(`   ‚ú® Created new season details: S${seasonNumber} D${divisionNumber}`);
            console.log(`   üìä Total season appearances: ${competitionHistory.numberOfSeasonAppearances}`);
        }
    }
}

/**
 * ====================================================================================
 * STEP 5-6: UPDATE FIGHTER OPPONENTS HISTORY
 * ====================================================================================
 * Updates head-to-head record with opponent and adds fight detail
 */
async function updateFighterOpponentsHistory(
    fighter,
    opponentId,
    competitionMetaId,
    seasonNumber,
    divisionNumber,
    roundNumber,
    fightId,
    isWinner,
    fightDate,
    fightIdentifier = null
) {
    console.log(`\nü•ä Step 5-6: Updating Opponents History for ${fighter.firstName} ${fighter.lastName}...`);
    
    const opponentsHistory = fighter.opponentsHistory || [];
    const existingOpponent = opponentsHistory.find(
        oh => oh.opponentId.toString() === opponentId.toString()
    );
    
    // For cup fights, extract stage code from fightIdentifier (e.g., "IC-S5-SF-F1" -> "SF")
    let roundValue = roundNumber;
    if (roundNumber === null && fightIdentifier) {
        const parts = fightIdentifier.split('-');
        if (parts.length >= 3) {
            roundValue = parts[2]; // Extract stage code (R1, SF, FN, etc.)
        }
    }
    
    const newDetail = {
        competitionId: competitionMetaId,
        season: seasonNumber,
        divisionId: divisionNumber,  // MongoDB schema uses divisionId
        roundId: roundValue,         // MongoDB schema uses roundId (now stores stage code for cups)
        fightId,
        isWinner,
        date: fightDate
    };
    
    if (existingOpponent) {
        existingOpponent.totalFights += 1;
        if (isWinner) {
            existingOpponent.totalWins += 1;
        } else {
            existingOpponent.totalLosses += 1;
        }
        existingOpponent.winPercentage = (existingOpponent.totalWins / existingOpponent.totalFights) * 100;
        existingOpponent.details.push(newDetail);
        
        console.log(`   ‚úì Updated vs opponent: ${existingOpponent.totalWins}W-${existingOpponent.totalLosses}L`);
    } else {
        fighter.opponentsHistory.push({
            opponentId,
            totalFights: 1,
            totalWins: isWinner ? 1 : 0,
            totalLosses: isWinner ? 0 : 1,
            winPercentage: isWinner ? 100 : 0,
            details: [newDetail]
        });
        
        console.log(`   ‚ú® New opponent record: ${isWinner ? '1W-0L' : '0W-1L'}`);
    }
}

/**
 * ====================================================================================
 * STEP 7A: UPDATE FIGHTER DEBUT INFORMATION (IF FIRST FIGHT)
 * ====================================================================================
 * Sets debut information if this is the fighter's first ever fight
 */
async function updateFighterDebutInformation(
    fighter,
    competitionMetaId,
    seasonNumber,
    fightId,
    fightDate
) {
    console.log(`\nüé¨ Step 7A: Checking Debut Information for ${fighter.firstName} ${fighter.lastName}...`);
    
    const hasDebut = fighter.debutInformation && 
                     fighter.debutInformation.competitionId && 
                     fighter.debutInformation.fightId;
    
    if (!hasDebut) {
        fighter.debutInformation = {
            competitionId: competitionMetaId,
            season: seasonNumber,
            fightId,
            dateOfDebut: fightDate
        };
        console.log(`   ‚ú® First fight ever! Debut recorded`);
    } else {
        console.log(`   ‚è≠Ô∏è  Already has debut (${fighter.debutInformation.competitionId})`);
    }
}

/**
 * ====================================================================================
 * STEP 7B: UPDATE FIGHTER STREAKS
 * ====================================================================================
 * Manages win/loss streaks - creates, continues, or breaks streaks
 */
async function updateFighterStreaks(
    fighter,
    competitionMetaId,
    seasonNumber,
    divisionNumber,
    roundNumber,
    opponentId,
    isWinner
) {
    console.log(`\nüî• Step 7B: Updating Streaks for ${fighter.firstName} ${fighter.lastName}...`);
    
    const streaks = fighter.streaks || [];
    const activeStreak = streaks.find(s => s.active === true);
    const resultType = isWinner ? 'win' : 'lose';
    
    if (!activeStreak) {
        // No active streak - create new one
        fighter.streaks.push({
            competitionId: competitionMetaId,
            type: resultType,
            start: { season: seasonNumber, division: divisionNumber, round: roundNumber },
            end: { season: seasonNumber, division: divisionNumber, round: roundNumber },
            count: 1,
            active: true,
            opponents: [opponentId]
        });
        console.log(`   ‚ú® Created new ${resultType} streak (count: 1)`);
    } else if (activeStreak.type === resultType) {
        // Streak continues
        activeStreak.count += 1;
        activeStreak.end = { season: seasonNumber, division: divisionNumber, round: roundNumber };
        activeStreak.opponents.push(opponentId);
        console.log(`   üìà ${resultType} streak continues (count: ${activeStreak.count})`);
    } else {
        // Streak breaks
        activeStreak.active = false;
        console.log(`   üíî ${activeStreak.type} streak broken at ${activeStreak.count}`);
        
        // Create new streak
        fighter.streaks.push({
            competitionId: competitionMetaId,
            type: resultType,
            start: { season: seasonNumber, division: divisionNumber, round: roundNumber },
            end: { season: seasonNumber, division: divisionNumber, round: roundNumber },
            count: 1,
            active: true,
            opponents: [opponentId]
        });
        console.log(`   ‚ú® Started new ${resultType} streak (count: 1)`);
    }
}

/**
 * ====================================================================================
 * STEP 7C: UPDATE FIGHTER FIGHT STATS (AVERAGING)
 * ====================================================================================
 * Updates lifetime fight statistics using weighted averaging
 */
async function updateFighterFightStats(fighter, chatGPTStats) {
    console.log(`\nüìä Step 7C: Updating Fight Stats for ${fighter.firstName} ${fighter.lastName}...`);
    
    const currentStats = fighter.fightStats || {};
    const currentCount = currentStats.fightsCount || 0;
    const newCount = currentCount + 1;
    
    // Helper to calculate weighted average
    const avg = (currentValue, newValue) => {
        if (currentCount === 0) return newValue || 0;
        const curr = currentValue || 0;
        const newVal = newValue || 0;
        return ((curr * currentCount) + newVal) / newCount;
    };
    
    // Update finishing moves (array of unique strings)
    const currentFinishingMoves = currentStats.finishingMoves || [];
    const newFinishingMove = chatGPTStats.finishingMove;
    console.log(`   - Current finishing moves:`, currentFinishingMoves);
    console.log(`   - New finishing move:`, newFinishingMove);
    if (newFinishingMove && !currentFinishingMoves.includes(newFinishingMove)) {
        currentFinishingMoves.push(newFinishingMove);
        console.log(`   ‚úì Added finishing move: ${newFinishingMove}`);
    } else if (newFinishingMove) {
        console.log(`   ‚ÑπÔ∏è  Finishing move already exists: ${newFinishingMove}`);
    } else {
        console.log(`   ‚ÑπÔ∏è  No finishing move (loser)`)
    }
    console.log(`   - Updated finishing moves:`, currentFinishingMoves);
    
    // Build updated stats with averaging
    fighter.fightStats = {
        fightsCount: newCount,
        avgFightTime: avg(currentStats.avgFightTime, chatGPTStats.fightTime),
        finishingMoves: currentFinishingMoves,
        grappling: {
            accuracy: avg(currentStats.grappling?.accuracy, chatGPTStats.grappling?.accuracy),
            defence: avg(currentStats.grappling?.defence, chatGPTStats.grappling?.defence)
        },
        significantStrikes: {
            accuracy: avg(currentStats.significantStrikes?.accuracy, chatGPTStats.significantStrikes?.accuracy),
            attempted: avg(currentStats.significantStrikes?.attempted, chatGPTStats.significantStrikes?.attempted),
            defence: avg(currentStats.significantStrikes?.defence, chatGPTStats.significantStrikes?.defence),
            landed: avg(currentStats.significantStrikes?.landed, chatGPTStats.significantStrikes?.landed),
            landedPerMinute: avg(currentStats.significantStrikes?.landedPerMinute, chatGPTStats.significantStrikes?.landedPerMinute),
            positions: {
                clinching: avg(currentStats.significantStrikes?.positions?.clinching, chatGPTStats.significantStrikes?.positions?.clinching),
                ground: avg(currentStats.significantStrikes?.positions?.ground, chatGPTStats.significantStrikes?.positions?.ground),
                standing: avg(currentStats.significantStrikes?.positions?.standing, chatGPTStats.significantStrikes?.positions?.standing)
            }
        },
        strikeMap: {
            head: {
                absorb: avg(currentStats.strikeMap?.head?.absorb, chatGPTStats.strikeMap?.head?.absorb),
                strike: avg(currentStats.strikeMap?.head?.strike, chatGPTStats.strikeMap?.head?.strike)
            },
            torso: {
                absorb: avg(currentStats.strikeMap?.torso?.absorb, chatGPTStats.strikeMap?.torso?.absorb),
                strike: avg(currentStats.strikeMap?.torso?.strike, chatGPTStats.strikeMap?.torso?.strike)
            },
            leg: {
                absorb: avg(currentStats.strikeMap?.leg?.absorb, chatGPTStats.strikeMap?.leg?.absorb),
                strike: avg(currentStats.strikeMap?.leg?.strike, chatGPTStats.strikeMap?.leg?.strike)
            }
        },
        submissions: {
            attemptsPer15Mins: avg(currentStats.submissions?.attemptsPer15Mins, chatGPTStats.submissions?.attemptsPer15Mins),
            average: avg(currentStats.submissions?.average, chatGPTStats.submissions?.average)
        },
        takedowns: {
            accuracy: avg(currentStats.takedowns?.accuracy, chatGPTStats.takedowns?.accuracy),
            attempted: avg(currentStats.takedowns?.attempted, chatGPTStats.takedowns?.attempted),
            avgTakedownsLandedPerMin: avg(currentStats.takedowns?.avgTakedownsLandedPerMin, chatGPTStats.takedowns?.avgTakedownsLandedPerMin),
            defence: avg(currentStats.takedowns?.defence, chatGPTStats.takedowns?.defence),
            landed: avg(currentStats.takedowns?.landed, chatGPTStats.takedowns?.landed)
        }
    };
    
    console.log(`   ‚úì Stats updated (fightsCount: ${currentCount} ‚Üí ${newCount})`);
    if (newFinishingMove) {
        console.log(`   ‚úì Finishing move: ${newFinishingMove}`);
    }
}

/**
 * ====================================================================================
 * CALCULATE ROUND STANDINGS (LEAGUE ONLY)
 * ====================================================================================
 * Calculates standings for all fighters in a division after this fight
 */
async function calculateAndSaveRoundStandings(
    competition,
    fightIdentifier,
    divisionNumber,
    roundNumber,
    competitionType,
    session
) {
    // Skip for cup competitions
    if (competitionType === 'cup') {
        console.log(`\n‚è≠Ô∏è  Round Standings: Skipped (cup competition)`);
        return;
    }
    
    console.log(`\nüìä Calculating Round Standings for ${fightIdentifier}...`);
    
    const division = competition.leagueData.divisions.find(
        d => d.divisionNumber === divisionNumber
    );
    
    if (!division) {
        console.warn(`   ‚ö†Ô∏è  Division ${divisionNumber} not found`);
        return;
    }
    
    // Get all division fighters
    const divisionFighters = competition.seasonMeta.leagueDivisions.find(
        ld => ld.divisionNumber === divisionNumber
    )?.fighters || [];
    
    console.log(`   - Division fighters: ${divisionFighters.length}`);
    
    // Get all completed fights in this division
    const allFights = [];
    division.rounds.forEach(round => {
        round.fights.forEach(fight => {
            if (fight.fightStatus === 'completed' || fight.winner) {
                allFights.push(fight);
            }
        });
    });
    
    console.log(`   - Completed fights: ${allFights.length}`);
    
    // Calculate stats for each fighter
    const fighterStatsMap = new Map();
    divisionFighters.forEach(fighterId => {
        fighterStatsMap.set(fighterId.toString(), {
            fighterId,
            fightsCount: 0,
            wins: 0,
            points: 0,
            rank: 0,
            totalFightersCount: divisionFighters.length
        });
    });
    
    // Process all completed fights
    allFights.forEach(fight => {
        const f1Id = fight.fighter1.toString();
        const f2Id = fight.fighter2.toString();
        const winnerId = fight.winner?.toString();
        
        const f1Stats = fighterStatsMap.get(f1Id);
        const f2Stats = fighterStatsMap.get(f2Id);
        
        if (f1Stats) {
            f1Stats.fightsCount++;
            if (winnerId === f1Id) {
                f1Stats.wins++;
                f1Stats.points += POINTS_PER_WIN;
            }
        }
        
        if (f2Stats) {
            f2Stats.fightsCount++;
            if (winnerId === f2Id) {
                f2Stats.wins++;
                f2Stats.points += POINTS_PER_WIN;
            }
        }
    });
    
    // Sort standings with tiebreakers
    const standings = sortStandingsWithTiebreakers(
        Array.from(fighterStatsMap.values()),
        allFights
    );
    
    console.log(`   ‚úì Standings calculated - Top 3:`);
    standings.slice(0, 3).forEach((s, idx) => {
        const trophy = idx === 0 ? ' üèÜ' : '';
        console.log(`      ${s.rank}. Fighter ${s.fighterId.toString().substring(0, 8)}... - ${s.points} pts (${s.wins}W)${trophy}`);
    });
    
    // Save to RoundStandings collection
    console.log('   üìù Saving standings to database...');
    console.log('      - Competition Meta ID:', competition.competitionMetaId._id);
    console.log('      - Competition ID:', competition._id);
    console.log('      - Season Number:', competition.seasonMeta.seasonNumber);
    console.log('      - Division Number:', divisionNumber);
    console.log('      - Round Number:', roundNumber);
    console.log('      - Fight Identifier:', fightIdentifier);
    
    const savedStandings = await RoundStandings.findOneAndUpdate(
        {
            competitionId: competition.competitionMetaId._id,
            seasonNumber: competition.seasonMeta.seasonNumber,
            divisionNumber,
            roundNumber,
            fightId: fightIdentifier
        },
        {
            fightIdentifier,
            standings,
            createdAt: new Date(),
            updatedAt: new Date()
        },
        {
            upsert: true,
            new: true,
            session
        }
    );
    
    console.log(`   ‚úì Round standings saved to database (ID: ${savedStandings._id})`);
    console.log(`   ‚úì Saved ${standings.length} fighter standings`);
}

/**
 * Sort standings with head-to-head tiebreakers
 */
function sortStandingsWithTiebreakers(standings, completedFights) {
    // Group by points
    const pointsGroups = new Map();
    standings.forEach(s => {
        const group = pointsGroups.get(s.points) || [];
        group.push(s.fighterId.toString());
        pointsGroups.set(s.points, group);
    });
    
    const fighterRankings = new Map();
    let currentRank = 1;
    
    // Sort points descending
    const sortedPoints = Array.from(pointsGroups.keys()).sort((a, b) => b - a);
    
    sortedPoints.forEach(points => {
        const tiedFighters = pointsGroups.get(points);
        
        if (tiedFighters.length === 1) {
            fighterRankings.set(tiedFighters[0], currentRank);
            currentRank++;
        } else {
            // Calculate head-to-head
            const h2hPoints = new Map();
            tiedFighters.forEach(fid => h2hPoints.set(fid, 0));
            
            completedFights.forEach(fight => {
                const f1 = fight.fighter1.toString();
                const f2 = fight.fighter2.toString();
                const winner = fight.winner?.toString();
                
                if (tiedFighters.includes(f1) && tiedFighters.includes(f2) && winner) {
                    const current = h2hPoints.get(winner) || 0;
                    h2hPoints.set(winner, current + POINTS_PER_WIN);
                }
            });
            
            // Sort by h2h, then alphabetically
            const sortedTied = [...tiedFighters].sort((a, b) => {
                const h2hA = h2hPoints.get(a) || 0;
                const h2hB = h2hPoints.get(b) || 0;
                if (h2hA !== h2hB) return h2hB - h2hA;
                return a.localeCompare(b);
            });
            
            sortedTied.forEach(fid => {
                fighterRankings.set(fid, currentRank);
                currentRank++;
            });
        }
    });
    
    // Apply ranks
    standings.forEach(s => {
        s.rank = fighterRankings.get(s.fighterId.toString()) || 999;
    });
    
    return standings.sort((a, b) => a.rank - b.rank);
}

/**
 * ====================================================================================
 * CHECK SEASON COMPLETION
 * ====================================================================================
 * Determines if all fights in the final round of all divisions are complete
 */
function checkSeasonCompletion(competition) {
    console.log(`\nüîç Checking Season Completion...`);
    
    const isLeague = competition.leagueData !== null && competition.leagueData !== undefined;
    
    if (isLeague) {
        const divisions = competition.leagueData.divisions;
        let allComplete = true;
        
        divisions.forEach(division => {
            const lastRound = division.rounds.find(r => r.roundNumber === division.totalRounds);
            if (!lastRound) {
                allComplete = false;
                return;
            }
            
            const totalFights = lastRound.fights.length;
            const completedFights = lastRound.fights.filter(
                f => f.fightStatus === 'completed' || f.winner
            ).length;
            
            console.log(`   üìä Division ${division.divisionNumber}: Round ${division.totalRounds} - ${completedFights}/${totalFights} fights completed`);
            
            if (completedFights < totalFights) {
                allComplete = false;
            }
        });
        
        if (allComplete) {
            console.log(`   ‚úÖ SEASON COMPLETED! All divisions finished.`);
        } else {
            console.log(`   ‚è≥ Season still in progress...`);
        }
        
        return allComplete;
    } else {
        // Cup competition - check if final fight(s) are complete
        const fights = competition.cupData?.fights || [];
        const finalFights = fights.filter(f => f.fightIdentifier.includes('-FN-')); // Finals stage
        if (finalFights.length === 0) return false;
        
        const allFinalsComplete = finalFights.every(f => f.fightStatus === 'completed' || f.winner);
        console.log(`   ${allFinalsComplete ? '‚úÖ CUP SEASON COMPLETED!' : '‚è≥ Cup in progress...'}`);
        
        return allFinalsComplete;
    }
}

/**
 * ====================================================================================
 * UPDATE CURRENT ROUND FOR DIVISION (LEAGUE ONLY)
 * ====================================================================================
 * Updates the currentRound field to reflect the latest completed fight
 */
function updateDivisionCurrentRound(competition, divisionNumber, roundNumber, competitionType) {
    if (competitionType !== 'league') {
        console.log(`\n‚è≠Ô∏è  Current Round Update: Skipped (cup competition)`);
        return;
    }
    
    console.log(`\nüîÑ Updating Current Round for Division ${divisionNumber}...`);
    
    const division = competition.leagueData.divisions.find(
        d => d.divisionNumber === divisionNumber
    );
    
    if (!division) {
        console.warn(`   ‚ö†Ô∏è  Division ${divisionNumber} not found`);
        return;
    }
    
    // Find the round that was just completed
    const round = division.rounds?.find(r => r.roundNumber === roundNumber);
    
    if (!round) {
        console.warn(`   ‚ö†Ô∏è  Round ${roundNumber} not found in division`);
        return;
    }
    
    // Count total fights and completed fights in this round
    const totalFights = round.fights?.length || 0;
    const completedFights = round.fights?.filter(f => f.winner).length || 0;
    
    console.log(`   üìä Round ${roundNumber} Status: ${completedFights}/${totalFights} fights complete`);
    
    const oldCurrentRound = division.currentRound || 0;
    
    // Only update currentRound if ALL fights in this round are complete
    if (completedFights === totalFights && totalFights > 0) {
        // Check if this is the last round
        if (roundNumber >= division.totalRounds) {
            // All rounds complete - keep currentRound at totalRounds
            if (oldCurrentRound !== division.totalRounds) {
                division.currentRound = division.totalRounds;
                console.log(`   ‚úÖ Division Complete! All ${division.totalRounds} rounds finished.`);
            } else {
                console.log(`   ‚úÖ Division already marked complete`);
            }
        } else {
            // Move to next round
            const newCurrentRound = roundNumber + 1;
            if (newCurrentRound > oldCurrentRound) {
                division.currentRound = newCurrentRound;
                console.log(`   ‚úì All fights in Round ${roundNumber} complete! Updated currentRound: ${oldCurrentRound} ‚Üí ${newCurrentRound}`);
            } else {
                console.log(`   ‚ÑπÔ∏è  currentRound unchanged: ${oldCurrentRound}`);
            }
        }
    } else {
        console.log(`   ‚ÑπÔ∏è  currentRound unchanged: ${oldCurrentRound} (Round ${roundNumber} still in progress)`);
    }
}

/**
 * ====================================================================================
 * HANDLE CUP BRACKET PROGRESSION
 * ====================================================================================
 * Advances winners to next round or marks champion for cup competitions
 */
async function handleCupBracketProgression(
    competition,
    fightIdentifier,
    winnerId,
    competitionType,
    session
) {
    if (competitionType !== 'cup') {
        console.log(`\n‚è≠Ô∏è  Cup Progression: Skipped (league competition)`);
        return;
    }
    
    console.log(`\nüèÜ Processing Cup Bracket Progression...`);
    console.log(`   Fight: ${fightIdentifier}`);
    console.log(`   Winner: ${winnerId.toString().substring(0, 8)}...`);
    
    // Parse fight identifier
    const parts = fightIdentifier.split('-');
    const stageCode = parts[2];
    const fightNumber = parseInt(parts[3].substring(1));
    const knockoutRounds = competition.config?.cupConfiguration?.knockoutRounds || 3;
    
    // Map stage code to round number
    let roundNumber;
    if (stageCode === 'FN') {
        roundNumber = knockoutRounds; // Finals is always the last round
    } else if (stageCode === 'SF') {
        roundNumber = knockoutRounds - 1; // Semifinals is second-to-last
    } else if (stageCode.startsWith('R')) {
        roundNumber = parseInt(stageCode.substring(1));
    } else {
        console.error(`   ‚ùå Unknown stage code: ${stageCode}`);
        return;
    }
    
    console.log(`   üìä Stage: ${stageCode}, Round ${roundNumber}, Fight ${fightNumber}`);
    
    // Check if this is the final
    if (roundNumber === knockoutRounds) {
        console.log(`   üéâ FINAL FIGHT! Updating season winner...`);
        competition.seasonMeta.winners = [winnerId];
        competition.isActive = false;
        competition.seasonMeta.endDate = new Date();
        
        // Update champion's titles
        await updateChampionTitle(winnerId, competition.competitionMetaId, competition._id, competition.seasonMeta.seasonNumber, session);
        
        return;
    }
    
    // Determine next round fight
    const nextRoundNumber = roundNumber + 1;
    const nextFightNumber = Math.ceil(fightNumber / 2);
    const isFirstFighterSlot = fightNumber % 2 === 1;
    
    // Map round numbers to stage codes
    // For cup competitions: R1, R2 (if exists), SF (semifinals), FN (finals)
    // The knockoutRounds includes all rounds: for 8 fighters, knockoutRounds=3 (R1, SF, FN)
    let nextStageCode;
    if (nextRoundNumber === knockoutRounds) {
        nextStageCode = 'FN'; // Finals
    } else if (nextRoundNumber === knockoutRounds - 1) {
        nextStageCode = 'SF'; // Semifinals
    } else {
        nextStageCode = `R${nextRoundNumber}`; // Earlier rounds
    }
    
    const nextFightIdentifier = `${parts[0]}-S${parts[1].substring(1)}-${nextStageCode}-F${nextFightNumber}`;
    
    console.log(`   ‚û°Ô∏è  Winner advances to: ${nextFightIdentifier} as ${isFirstFighterSlot ? 'Fighter 1' : 'Fighter 2'}`);
    
    // Find the existing fight for the next round
    const existingFight = competition.cupData.fights.find(f => f.fightIdentifier === nextFightIdentifier);
    
    if (existingFight) {
        // Update the appropriate fighter slot
        if (isFirstFighterSlot) {
            existingFight.fighter1 = winnerId;
        } else {
            existingFight.fighter2 = winnerId;
        }
        console.log(`   ‚úì Updated existing fight: ${nextFightIdentifier}`);
    } else {
        // The fight doesn't exist yet. We need to determine if we should create it now.
        // We can only create a fight when BOTH fighters are known.
        
        // Use the stage code from the fight identifier (already parsed above)
        const currentStageCode = stageCode;
        
        // Calculate which two previous fights feed into this next fight
        const previousFight1Number = (nextFightNumber - 1) * 2 + 1;
        const previousFight2Number = (nextFightNumber - 1) * 2 + 2;
        const previousFight1Identifier = `${parts[0]}-S${parts[1].substring(1)}-${currentStageCode}-F${previousFight1Number}`;
        const previousFight2Identifier = `${parts[0]}-S${parts[1].substring(1)}-${currentStageCode}-F${previousFight2Number}`;
        
        // Find both previous fights
        const prevFight1 = competition.cupData.fights.find(f => f.fightIdentifier === previousFight1Identifier);
        const prevFight2 = competition.cupData.fights.find(f => f.fightIdentifier === previousFight2Identifier);
        
        // Check if both previous fights have winners
        if (prevFight1?.winner && prevFight2?.winner) {
            // Both winners are known, create the next fight
            competition.cupData.fights.push({
                fighter1: prevFight1.winner,
                fighter2: prevFight2.winner,
                fightIdentifier: nextFightIdentifier,
                isSimulated: false,
                fighterStats: [],
                fightStatus: 'scheduled'
            });
            console.log(`   ‚ú® Created new fight: ${nextFightIdentifier} (both fighters known)`);
        } else {
            // Only one winner is known, don't create the fight yet
            console.log(`   ‚è≥ Waiting for other fight to complete before creating ${nextFightIdentifier}`);
            console.log(`      Previous Fight 1 (${previousFight1Identifier}): ${prevFight1?.winner ? '‚úì Has winner' : '‚úó No winner'}`);
            console.log(`      Previous Fight 2 (${previousFight2Identifier}): ${prevFight2?.winner ? '‚úì Has winner' : '‚úó No winner'}`);
        }
    }
}

/**
 * Update champion's title count
 */
async function updateChampionTitle(championId, competitionMetaId, competitionSeasonId, seasonNumber, session) {
    console.log(`\nüèÜ Updating Champion Title...`);
    
    const champion = await Fighter.findById(championId).session(session);
    if (!champion) {
        console.error(`   ‚ùå Champion not found: ${championId}`);
        return;
    }
    
    const compHistory = champion.competitionHistory.find(
        ch => ch.competitionId.toString() === competitionMetaId.toString()
    );
    
    if (!compHistory) {
        console.error(`   ‚ùå Competition history not found`);
        return;
    }
    
    if (!compHistory.titles) {
        compHistory.titles = { totalTitles: 0, details: [] };
    }
    
    compHistory.titles.totalTitles += 1;
    compHistory.titles.details.push({
        competitionSeasonId,
        seasonNumber
    });
    
    await champion.save({ session });
    
    console.log(`   ‚úì ${champion.firstName} ${champion.lastName} now has ${compHistory.titles.totalTitles} title(s)`);
}

/**
 * ====================================================================================
 * CHECK AND CREATE IC SEASON (25% LEAGUE COMPLETION)
 * ====================================================================================
 * Creates Invicta Cup season when league reaches exactly 25% completion
 */
async function checkAndCreateICSeasonIfNeeded(competition, session) {
    console.log(`\nüîç Checking if IC Season should be created...`);
    
    // Calculate completion percentage
    const divisions = competition.leagueData.divisions;
    let totalFights = 0;
    let completedFights = 0;
    
    divisions.forEach(division => {
        division.rounds.forEach(round => {
            const fights = round.fights || [];
            totalFights += fights.length;
            completedFights += fights.filter(f => f.fightStatus === 'completed' || f.winner).length;
        });
    });
    
    const completionPercentage = totalFights > 0 ? (completedFights / totalFights) * 100 : 0;
    console.log(`   üìä Completion: ${completedFights}/${totalFights} fights (${completionPercentage.toFixed(2)}%)`);
    
    // Check if exactly at 25% (with small tolerance for floating point)
    if (Math.abs(completionPercentage - 25) > 0.5) {
        if (completionPercentage > 25) {
            console.log('   ‚è≠Ô∏è  Skipping: Already past 25% threshold');
        } else {
            console.log('   ‚è≥ Not yet at 25% threshold');
        }
        return;
    }
    
    console.log('‚úÖ Exactly at 25% completion! Creating IC season...');
    
    try {
        // 1. Query IC competition meta
        const icMeta = await CompetitionMeta.findOne({
            competitionName: 'Invicta Cup',
            type: 'cup'
        }).session(session);
        
        if (!icMeta) {
            console.error('   ‚ùå Error: IC competition meta not found');
            return;
        }
        
        console.log(`   ‚úì Found IC meta: ${icMeta._id}`);
        
        // 2. Check if IC season already exists for this league season
        const existingICSeasons = await Competition.find({
            competitionMetaId: icMeta._id,
            'linkedLeagueSeason.competition': competition.competitionMetaId,
            'linkedLeagueSeason.season': competition._id
        }).session(session);
        
        if (existingICSeasons.length > 0) {
            console.log('   ‚è≠Ô∏è  Skipping: IC season already exists for this league season');
            return;
        }
        
        // 3. Check if there's already an active IC season
        const activeICSeasons = await Competition.find({
            competitionMetaId: icMeta._id,
            isActive: true
        }).session(session);
        
        if (activeICSeasons.length > 0) {
            console.log('   ‚è≠Ô∏è  Skipping: An active IC season already exists');
            console.log(`      Active IC: ${activeICSeasons[0]._id} (S${activeICSeasons[0].seasonMeta.seasonNumber})`);
            return;
        }
        
        // 4. Find previous IC champion
        const previousICSeason = await Competition.findOne({
            competitionMetaId: icMeta._id
        })
        .sort({ 'seasonMeta.seasonNumber': -1 })
        .limit(1)
        .session(session);
        
        const previousChampion = previousICSeason?.seasonMeta?.winners?.[0];
        const newICSeasonNumber = (previousICSeason?.seasonMeta?.seasonNumber || 0) + 1;
        
        console.log(`   üëë Previous IC champion: ${previousChampion ? previousChampion.toString().substring(0, 8) + '...' : 'None'}`);
        console.log(`   üìä New IC season number: ${newICSeasonNumber}`);
        
        // 5. Get all fighters from current league season
        const allLeagueFighters = [];
        const divisionFightersMap = new Map();
        
        competition.seasonMeta.leagueDivisions.forEach(division => {
            const fighters = division.fighters || [];
            divisionFightersMap.set(division.divisionNumber, fighters);
            allLeagueFighters.push(...fighters.map(f => f.toString()));
        });
        
        console.log(`   üë• Total league fighters: ${allLeagueFighters.length}`);
        
        // 6. Select 8 fighters (1 champion + 7 from league)
        const selectedFighters = [];
        
        // Add previous champion if exists and is in current league
        if (previousChampion && allLeagueFighters.includes(previousChampion.toString())) {
            selectedFighters.push(previousChampion);
            console.log(`   ‚úì Champion ${previousChampion.toString().substring(0, 8)}... included`);
        }
        
        // Remove champion from available pool
        const availableFighters = allLeagueFighters.filter(
            id => !selectedFighters.some(sf => sf.toString() === id)
        );
        
        if (availableFighters.length < (8 - selectedFighters.length)) {
            console.error(`   ‚ùå Error: Not enough fighters (need ${8 - selectedFighters.length}, have ${availableFighters.length})`);
            return;
        }
        
        // Ensure at least 1 fighter from each division
        const fightersToSelect = new Set();
        divisionFightersMap.forEach((fighters, divisionNumber) => {
            const divisionAvailable = fighters.filter(
                f => !selectedFighters.some(sf => sf.toString() === f.toString())
            );
            if (divisionAvailable.length > 0) {
                const randomIndex = Math.floor(Math.random() * divisionAvailable.length);
                const selected = divisionAvailable[randomIndex];
                fightersToSelect.add(selected.toString());
                console.log(`   ‚úì Division ${divisionNumber}: Selected ${selected.toString().substring(0, 8)}...`);
            }
        });
        
        // Fill remaining spots randomly
        const remainingFighters = availableFighters.filter(id => !fightersToSelect.has(id));
        const needMoreFighters = (8 - selectedFighters.length) - fightersToSelect.size;
        
        if (needMoreFighters > 0) {
            const shuffled = remainingFighters.sort(() => Math.random() - 0.5);
            for (let i = 0; i < Math.min(needMoreFighters, shuffled.length); i++) {
                fightersToSelect.add(shuffled[i]);
                console.log(`   ‚úì Random: Selected ${shuffled[i].substring(0, 8)}...`);
            }
        }
        
        selectedFighters.push(...Array.from(fightersToSelect).slice(0, 8 - selectedFighters.length));
        
        if (selectedFighters.length !== 8) {
            console.error(`   ‚ùå Error: Could not select exactly 8 fighters (got ${selectedFighters.length})`);
            return;
        }
        
        console.log(`   ‚úÖ Selected 8 fighters for IC season`);
        
        // 7. Create random pairings for Round 1 (4 fights)
        const shuffledFighters = [...selectedFighters].sort(() => Math.random() - 0.5);
        const round1Fights = [];
        
        for (let i = 0; i < 4; i++) {
            const fighter1 = shuffledFighters[i * 2];
            const fighter2 = shuffledFighters[i * 2 + 1];
            const fightIdentifier = `IC-S${newICSeasonNumber}-R1-F${i + 1}`;
            
            round1Fights.push({
                fighter1,
                fighter2,
                winner: null,
                fightIdentifier,
                date: null,
                userDescription: null,
                genAIDescription: null,
                isSimulated: false,
                fighterStats: [],
                fightStatus: 'scheduled'
            });
            
            console.log(`   ü•ä Fight ${i + 1}: ${fighter1.toString().substring(0, 8)}... vs ${fighter2.toString().substring(0, 8)}...`);
        }
        
        // 8. Create IC season document
        const newICSeason = new Competition({
            competitionMetaId: icMeta._id,
            isActive: true,
            seasonMeta: {
                seasonNumber: newICSeasonNumber,
                startDate: new Date(),
                endDate: null,
                winners: [],
                leagueDivisions: null,
                cupParticipants: {
                    fighters: selectedFighters
                }
            },
            leagueData: null,
            cupData: {
                fights: round1Fights,
                currentStage: 'Round 1',
                rounds: null
            },
            config: {
                leagueConfiguration: null,
                cupConfiguration: {
                    knockoutRounds: 3,
                    numberOfFighters: 8,
                    perFightFeeInEur: 10000,
                    winningFeeInEur: 100000,
                    stages: ['Round 1', 'Semi-finals', 'Finals']
                }
            },
            linkedLeagueSeason: {
                competition: competition.competitionMetaId,
                season: competition._id
            }
        });
        
        await newICSeason.save({ session });
        
        console.log('\n‚ú® IC Season created successfully!');
        console.log(`   üèÜ Season: IC S${newICSeasonNumber}`);
        console.log(`   üë• Participants: 8 fighters`);
        console.log(`   ü•ä Round 1 Fights: 4 (all scheduled)`);
        console.log(`   üîó Linked to: League ${competition._id.toString().substring(0, 8)}... S${competition.seasonMeta.seasonNumber}`);
        console.log(`   üíæ Saved to MongoDB: ${newICSeason._id}`);
        
    } catch (error) {
        console.error('   ‚ùå Error creating IC season:', error.message);
        throw error; // Will trigger transaction rollback
    }
}

/**
 * ====================================================================================
 * POPULATE DIVISION WINNERS
 * ====================================================================================
 * Updates seasonMeta.leagueDivisions[].winners with rank 1 fighters from final standings
 */
async function populateDivisionWinners(competition, session) {
    console.log(`\nüèÜ Populating Division Winners...`);
    
    try {
        for (let divisionNumber = 1; divisionNumber <= 3; divisionNumber++) {
            // Get final standings for this division
            // Note: Not using .session(session) because standings were created in previous transactions
            const finalStandings = await RoundStandings.findOne({
                competitionId: competition.competitionMetaId,
                seasonNumber: competition.seasonMeta.seasonNumber,
                divisionNumber: divisionNumber
            })
            .sort({ roundNumber: -1 })
            .limit(1);
            
            if (!finalStandings || !finalStandings.standings) {
                console.warn(`   ‚ö†Ô∏è  No standings found for Division ${divisionNumber}`);
                continue;
            }
            
            // Find all fighters with rank 1 (handles ties)
            const winners = finalStandings.standings
                .filter(s => s.rank === 1)
                .map(s => s.fighterId);
            
            if (winners.length === 0) {
                console.warn(`   ‚ö†Ô∏è  No rank 1 fighter found in Division ${divisionNumber}`);
                continue;
            }
            
            // Update the division's winners array
            const divisionMeta = competition.seasonMeta.leagueDivisions.find(
                ld => ld.divisionNumber === divisionNumber
            );
            
            if (divisionMeta) {
                divisionMeta.winners = winners;
                
                const emoji = divisionNumber === 1 ? 'ü•á' : divisionNumber === 2 ? 'ü•à' : 'ü•â';
                if (winners.length === 1) {
                    console.log(`   ${emoji} Division ${divisionNumber} Winner: ${winners[0].toString().substring(0, 8)}...`);
                } else {
                    console.log(`   ${emoji} Division ${divisionNumber} Winners (tie): ${winners.map(w => w.toString().substring(0, 8) + '...').join(', ')}`);
                }
            }
        }
        
        console.log(`   ‚úÖ Division winners populated successfully`);
        
    } catch (error) {
        console.error('   ‚ùå Error populating division winners:', error.message);
        throw error;
    }
}

/**
 * ====================================================================================
 * POPULATE FINAL POSITIONS FOR ALL FIGHTERS
 * ====================================================================================
 * Updates finalPosition for all fighters based on final standings (league only)
 */
async function populateFinalPositions(competition, session) {
    console.log(`\nüìä Populating Final Positions...`);
    
    try {
        for (const divisionMeta of competition.seasonMeta.leagueDivisions) {
            console.log(`\n  Division ${divisionMeta.divisionNumber}:`);
            
            // Get final standings for this division
            const finalStandings = await RoundStandings.findOne({
                competitionId: competition.competitionMetaId,
                seasonNumber: competition.seasonMeta.seasonNumber,
                divisionNumber: divisionMeta.divisionNumber
            })
            .sort({ roundNumber: -1 })
            .limit(1);
            
            if (!finalStandings || !finalStandings.standings) {
                console.warn(`    ‚ö†Ô∏è  No final standings found`);
                continue;
            }
            
            // Update each fighter's finalPosition
            for (const standing of finalStandings.standings) {
                const fighter = await Fighter.findById(standing.fighterId);
                
                if (!fighter) {
                    console.warn(`    ‚ö†Ô∏è  Fighter ${standing.fighterId.toString().substring(0, 8)}... not found`);
                    continue;
                }
                
                // Find competition history
                // competitionMetaId might be populated, so extract _id
                const compMetaId = competition.competitionMetaId._id || competition.competitionMetaId;
                const compHistory = fighter.competitionHistory.find(
                    ch => ch.competitionId.toString() === compMetaId.toString()
                );
                
                if (!compHistory) {
                    console.warn(`    ‚ö†Ô∏è  No comp history for ${fighter.firstName} ${fighter.lastName}`);
                    continue;
                }
                
                // Find season details using .find() on the array
                const seasonDetail = compHistory.seasonDetails.find(
                    sd => sd.seasonNumber === competition.seasonMeta.seasonNumber && 
                          sd.divisionNumber === divisionMeta.divisionNumber
                );
                
                if (!seasonDetail) {
                    console.warn(`    ‚ö†Ô∏è  No season details for ${fighter.firstName} ${fighter.lastName} S${competition.seasonMeta.seasonNumber} D${divisionMeta.divisionNumber}`);
                    continue;
                }
                
                // Set final position from standings rank
                seasonDetail.finalPosition = standing.rank;
                
                await fighter.save({ session });
                
                console.log(`    ‚úÖ ${fighter.firstName} ${fighter.lastName}: Position ${standing.rank} (${standing.wins}W, ${standing.points} pts)`);
            }
        }
        
        console.log(`\n   ‚úÖ Final positions populated successfully`);
        
    } catch (error) {
        console.error('   ‚ùå Error populating final positions:', error.message);
        throw error;
    }
}

/**
 * ====================================================================================
 * POPULATE FINAL CUP POSITIONS FOR ALL PARTICIPANTS
 * ====================================================================================
 * Updates finalCupPosition for all cup participants based on how far they got (cup only)
 */
async function populateFinalCupPositions(competition, session) {
    console.log(`\nüèÜ Populating Final Cup Positions...`);
    
    try {
        const stages = competition.config?.cupConfiguration?.stages || ['Round 1', 'Semi-finals', 'Finals'];
        const allFighters = competition.seasonMeta.cupParticipants?.fighters || [];
        
        // Determine final position for each fighter based on their last fight
        for (const fighterId of allFighters) {
            const fighter = await Fighter.findById(fighterId);
            
            if (!fighter) {
                console.warn(`   ‚ö†Ô∏è  Fighter ${fighterId.toString().substring(0, 8)}... not found`);
                continue;
            }
            
            // Find competition history
            // competitionMetaId might be populated, so extract _id
            const compMetaId = competition.competitionMetaId._id || competition.competitionMetaId;
            const compHistory = fighter.competitionHistory.find(
                ch => ch.competitionId.toString() === compMetaId.toString()
            );
            
            if (!compHistory) {
                console.warn(`   ‚ö†Ô∏è  No comp history for ${fighter.firstName} ${fighter.lastName}`);
                continue;
            }
            
            // Find season details
            const seasonDetail = compHistory.seasonDetails.find(
                sd => sd.seasonNumber === competition.seasonMeta.seasonNumber
            );
            
            if (!seasonDetail) {
                console.warn(`   ‚ö†Ô∏è  No season details for ${fighter.firstName} ${fighter.lastName} S${competition.seasonMeta.seasonNumber}`);
                continue;
            }
            
            // Determine final cup position based on wins/losses in this cup
            let finalCupPosition = stages[0]; // Default to first round
            
            // Check if they are the champion
            if (competition.seasonMeta.winners?.length > 0 && 
                competition.seasonMeta.winners[0].toString() === fighterId.toString()) {
                finalCupPosition = 'Champion';
            } else {
                // Find their last fight to determine position
                const fighterFights = competition.cupData.fights.filter(
                    f => (f.fighter1?.toString() === fighterId.toString() || 
                          f.fighter2?.toString() === fighterId.toString()) &&
                         (f.fightStatus === 'completed' || f.winner)
                );
                
                if (fighterFights.length > 0) {
                    // Get the stage of their last fight
                    const lastFight = fighterFights[fighterFights.length - 1];
                    const identifier = lastFight.fightIdentifier;
                    
                    // Extract stage from identifier (e.g., "IC-S5-SF-F1" -> "SF")
                    const parts = identifier.split('-');
                    const stageCode = parts[2];
                    
                    // Map stage code to position name
                    if (stageCode === 'FN' || stageCode.includes('FINAL')) {
                        finalCupPosition = stages[stages.length - 1]; // Finals
                    } else if (stageCode === 'SF' || stageCode.includes('SEMI')) {
                        finalCupPosition = stages[stages.length - 2]; // Semi-finals
                    } else {
                        finalCupPosition = stages[0]; // Round 1
                    }
                }
            }
            
            seasonDetail.finalCupPosition = finalCupPosition;
            
            await fighter.save({ session });
            
            console.log(`   ‚úÖ ${fighter.firstName} ${fighter.lastName}: ${finalCupPosition}`);
        }
        
        console.log(`\n   ‚úÖ Final cup positions populated successfully`);
        
    } catch (error) {
        console.error('   ‚ùå Error populating final cup positions:', error.message);
        throw error;
    }
}

/**
 * ====================================================================================
 * UPDATE CUP WINNER TITLE
 * ====================================================================================
 * Updates title for cup champion (cup only)
 */
async function updateCupWinnerTitle(competition, session) {
    console.log(`\nüèÜ Updating Cup Winner Title...`);
    
    try {
        if (!competition.seasonMeta.winners || competition.seasonMeta.winners.length === 0) {
            console.warn(`   ‚ö†Ô∏è  No cup winner found`);
            return;
        }
        
        const winnerId = competition.seasonMeta.winners[0];
        // Don't use session for reading fighter data
        const fighter = await Fighter.findById(winnerId);
        
        if (!fighter) {
            console.warn(`   ‚ö†Ô∏è  Winner fighter not found: ${winnerId.toString().substring(0, 8)}...`);
            return;
        }
        
        // Find competition history for this cup
        // competitionMetaId might be populated, so extract _id
        const compMetaId = competition.competitionMetaId._id || competition.competitionMetaId;
        let compHistory = fighter.competitionHistory.find(
            ch => ch.competitionId.toString() === compMetaId.toString()
        );
        
        if (!compHistory) {
            console.warn(`   ‚ö†Ô∏è  No competition history for ${fighter.firstName} ${fighter.lastName}`);
            return;
        }
        
        // Initialize titles if not exists
        if (!compHistory.titles) {
            compHistory.titles = { totalTitles: 0, details: [] };
        }
        
        // Check if title already exists for this season
        const existingTitle = compHistory.titles.details.find(
            t => t.seasonNumber === competition.seasonMeta.seasonNumber
        );
        
        if (!existingTitle) {
            // Add new title (no divisionNumber for cup competitions)
            compHistory.titles.details.push({
                competitionSeasonId: competition._id,
                seasonNumber: competition.seasonMeta.seasonNumber,
                divisionNumber: null
            });
            
            compHistory.titles.totalTitles = (compHistory.titles.totalTitles || 0) + 1;
            
            await fighter.save({ session });
            
            console.log(`   ‚úÖ ${fighter.firstName} ${fighter.lastName}: Cup title added (Total: ${compHistory.titles.totalTitles})`);
        } else {
            console.log(`   ‚ÑπÔ∏è  ${fighter.firstName} ${fighter.lastName}: Title already exists`);
        }
        
        console.log(`   ‚úÖ Cup winner title updated`);
        
    } catch (error) {
        console.error('   ‚ùå Error updating cup winner title:', error.message);
        throw error;
    }
}

/**
 * ====================================================================================
 * UPDATE CUP POSITIONS FOR NON-FINALISTS
 * ====================================================================================
 * Updates final cup positions for participants who didn't reach the finals
 * (Finals participants get their positions updated during main fight processing)
 */
async function updateCupWinnerTitleAndPositions(competition, session) {
    console.log(`\nüèÜ Updating Cup Positions for Non-Finalists...`);
    
    try {
        const compMetaId = competition.competitionMetaId._id || competition.competitionMetaId;
        const allParticipantIds = competition.seasonMeta.cupParticipants?.fighters || [];
        
        if (allParticipantIds.length === 0) {
            console.warn(`   ‚ö†Ô∏è  No cup participants found`);
            return;
        }
        
        // Find the finals fight to identify finalists (they're already updated in main loop)
        const finalFight = competition.cupData.fights.find(f => f.fightIdentifier.includes('-FN-'));
        const finalistIds = finalFight ? [
            finalFight.fighter1?.toString(),
            finalFight.fighter2?.toString()
        ].filter(Boolean) : [];
        
        // Process all non-finalist participants
        for (const fighterId of allParticipantIds) {
            // Skip finalists - they were already updated in the main fight processing loop
            if (finalistIds.includes(fighterId.toString())) {
                console.log(`   ‚è≠Ô∏è  Skipping finalist: ${fighterId.toString().substring(0, 8)}... (already updated)`);
                continue;
            }
            // Use session to get the latest version from this transaction
            const fighter = await Fighter.findById(fighterId).session(session);
            
            if (!fighter) {
                console.log(`   ‚ùå Fighter not found: ${fighterId.toString().substring(0, 8)}...`);
                continue;
            }
            
            let compHistory = fighter.competitionHistory.find(
                ch => ch.competitionId.toString() === compMetaId.toString()
            );
            
            if (!compHistory) {
                console.log(`   ‚ùå Competition history not found for ${fighter.firstName} ${fighter.lastName}`);
                continue;
            }
            
            let seasonDetail = compHistory.seasonDetails.find(
                sd => sd.seasonNumber === competition.seasonMeta.seasonNumber
            );
            
            if (!seasonDetail) {
                console.log(`   ‚ùå Season ${competition.seasonMeta.seasonNumber} not found for ${fighter.firstName} ${fighter.lastName}`);
                continue;
            }
            
            // Update final cup position if not already set
            if (!seasonDetail.finalCupPosition || seasonDetail.finalCupPosition === 'Round 1') {
                const fighterFights = competition.cupData.fights.filter(
                    f => (f.fighter1?.toString() === fighterId.toString() || 
                          f.fighter2?.toString() === fighterId.toString()) &&
                         (f.fightStatus === 'completed' || f.winner)
                );
                
                if (fighterFights.length > 0) {
                    const lastFight = fighterFights[fighterFights.length - 1];
                    
                    if (lastFight.fightIdentifier.includes('-FN-')) {
                        seasonDetail.finalCupPosition = 'Finals';
                    } else if (lastFight.fightIdentifier.includes('-SF-')) {
                        seasonDetail.finalCupPosition = 'Semifinals';
                    } else {
                        seasonDetail.finalCupPosition = 'Round 1';
                    }
                    
                    await fighter.save({ session });
                    console.log(`   ‚úÖ ${fighter.firstName} ${fighter.lastName}: ${seasonDetail.finalCupPosition}`);
                } else {
                    console.log(`   ‚ö†Ô∏è  ${fighter.firstName} ${fighter.lastName}: No completed fights found`);
                }
            } else {
                console.log(`   ‚ÑπÔ∏è  ${fighter.firstName} ${fighter.lastName}: Position already set (${seasonDetail.finalCupPosition})`);
            }
        }
        
        console.log(`   ‚úÖ Cup positions updated for non-finalists`);
        
    } catch (error) {
        console.error('   ‚ùå Error updating cup winner title and positions:', error.message);
        throw error;
    }
}

/**
 * ====================================================================================
 * UPDATE DIVISION WINNER TITLES AND POSITIONS (COMBINED)
 * ====================================================================================
 * Updates titles for winners AND final positions for all fighters in one pass
 * This avoids Mongoose version conflicts from multiple saves on same document
 */
async function updateDivisionWinnerTitlesAndPositions(competition, session) {
    console.log(`\nüèÜ Updating Division Winner Titles and Final Positions...`);
    
    try {
        const compMetaId = competition.competitionMetaId._id || competition.competitionMetaId;
        
        for (const divisionMeta of competition.seasonMeta.leagueDivisions) {
            console.log(`\n  Division ${divisionMeta.divisionNumber}:`);
            
            // Get final standings for this division
            const finalStandings = await RoundStandings.findOne({
                competitionId: compMetaId,
                seasonNumber: competition.seasonMeta.seasonNumber,
                divisionNumber: divisionMeta.divisionNumber
            })
            .sort({ roundNumber: -1 })
            .limit(1);
            
            if (!finalStandings || !finalStandings.standings) {
                console.warn(`    ‚ö†Ô∏è  No final standings found`);
                continue;
            }
            
            // Process each fighter in standings
            for (const standing of finalStandings.standings) {
                const fighter = await Fighter.findById(standing.fighterId);
                
                if (!fighter) continue;
                
                // Find competition history
                const compHistory = fighter.competitionHistory.find(
                    ch => ch.competitionId.toString() === compMetaId.toString()
                );
                
                if (!compHistory) continue;
                
                // Find season details
                const seasonDetail = compHistory.seasonDetails.find(
                    sd => sd.seasonNumber === competition.seasonMeta.seasonNumber && 
                          sd.divisionNumber === divisionMeta.divisionNumber
                );
                
                if (!seasonDetail) continue;
                
                // Update final position for ALL fighters
                seasonDetail.finalPosition = standing.rank;
                
                // Check if this fighter is a division winner
                const isWinner = divisionMeta.winners?.some(
                    w => w.toString() === standing.fighterId.toString()
                );
                
                if (isWinner) {
                    // Initialize titles if not exists
                    if (!compHistory.titles) {
                        compHistory.titles = { totalTitles: 0, details: [] };
                    }
                    
                    // Check if title already exists
                    const existingTitle = compHistory.titles.details.find(
                        t => t.seasonNumber === competition.seasonMeta.seasonNumber && 
                             t.divisionNumber === divisionMeta.divisionNumber
                    );
                    
                    if (!existingTitle) {
                        // Add new title
                        compHistory.titles.details.push({
                            competitionSeasonId: competition._id,
                            seasonNumber: competition.seasonMeta.seasonNumber,
                            divisionNumber: divisionMeta.divisionNumber
                        });
                        
                        compHistory.titles.totalTitles = (compHistory.titles.totalTitles || 0) + 1;
                        
                        console.log(`    üèÜ ${fighter.firstName} ${fighter.lastName}: Position ${standing.rank} + TITLE (Total: ${compHistory.titles.totalTitles})`);
                    } else {
                        console.log(`    ‚úÖ ${fighter.firstName} ${fighter.lastName}: Position ${standing.rank} (title exists)`);
                    }
                } else {
                    console.log(`    ‚úÖ ${fighter.firstName} ${fighter.lastName}: Position ${standing.rank}`);
                }
                
                // Save once with all updates
                await fighter.save({ session });
            }
        }
        
        console.log(`\n   ‚úÖ Division winner titles and final positions updated successfully`);
        
    } catch (error) {
        console.error('   ‚ùå Error updating titles and positions:', error.message);
        throw error;
    }
}

/**
 * ====================================================================================
 * UPDATE DIVISION WINNER TITLES (OLD - DEPRECATED)
 * ====================================================================================
 * Updates titles for division winners (league only)
 * NOTE: This is now handled by updateDivisionWinnerTitlesAndPositions
 */
async function updateDivisionWinnerTitles(competition, session) {
    console.log(`\nüèÜ Updating Division Winner Titles...`);
    
    try {
        for (const divisionMeta of competition.seasonMeta.leagueDivisions) {
            if (!divisionMeta.winners || divisionMeta.winners.length === 0) {
                continue;
            }
            
            for (const winnerId of divisionMeta.winners) {
                // Don't use session for reading fighter data (causes issues finding existing data)
                const fighter = await Fighter.findById(winnerId);
                
                if (!fighter) {
                    console.warn(`   ‚ö†Ô∏è  Fighter ${winnerId.toString().substring(0, 8)}... not found`);
                    continue;
                }
                
                // Find competition history for this league
                // competitionMetaId might be populated, so extract _id
                const compMetaId = competition.competitionMetaId._id || competition.competitionMetaId;
                let compHistory = fighter.competitionHistory.find(
                    ch => ch.competitionId.toString() === compMetaId.toString()
                );
                
                if (!compHistory) {
                    console.warn(`   ‚ö†Ô∏è  No competition history for ${fighter.firstName} ${fighter.lastName}`);
                    console.warn(`   Looking for CompMeta ID: ${compMetaId.toString()}`);
                    console.warn(`   Fighter has ${fighter.competitionHistory.length} competition entries`);
                    continue;
                }
                
                // Initialize titles if not exists
                if (!compHistory.titles) {
                    compHistory.titles = { totalTitles: 0, details: [] };
                }
                
                // Check if title already exists for this season/division
                const existingTitle = compHistory.titles.details.find(
                    t => t.seasonNumber === competition.seasonMeta.seasonNumber && 
                         t.divisionNumber === divisionMeta.divisionNumber
                );
                
                if (!existingTitle) {
                    // Add new title
                    compHistory.titles.details.push({
                        competitionSeasonId: competition._id,
                        seasonNumber: competition.seasonMeta.seasonNumber,
                        divisionNumber: divisionMeta.divisionNumber
                    });
                    
                    compHistory.titles.totalTitles = (compHistory.titles.totalTitles || 0) + 1;
                    
                    await fighter.save({ session });
                    
                    console.log(`   ‚úÖ Division ${divisionMeta.divisionNumber} - ${fighter.firstName} ${fighter.lastName}: Title added (Total: ${compHistory.titles.totalTitles})`);
                } else {
                    console.log(`   ‚ÑπÔ∏è  Division ${divisionMeta.divisionNumber} - ${fighter.firstName} ${fighter.lastName}: Title already exists`);
                }
            }
        }
        
        console.log(`   ‚úÖ Division winner titles updated`);
        
    } catch (error) {
        console.error('   ‚ùå Error updating division winner titles:', error.message);
        throw error;
    }
}

/**
 * ====================================================================================
 * CHECK AND CREATE CC SEASON (100% LEAGUE COMPLETION)
 * ====================================================================================
 * Creates Champions Cup season when league is 100% complete
 */
async function checkAndCreateCCSeasonIfNeeded(competition, session) {
    console.log(`\nüèÜ Checking if CC Season should be created...`);
    
    try {
        // 1. Query CC competition meta (read-only, no session needed)
        const ccMeta = await CompetitionMeta.findOne({
            competitionName: "Champions' Cup",
            type: 'cup'
        });
        
        if (!ccMeta) {
            console.error('   ‚ùå Error: CC competition meta not found');
            return;
        }
        
        console.log(`   ‚úì Found CC meta: ${ccMeta._id}`);
        
        // 2. Check if CC season already exists for this league season (read-only, no session needed)
        const existingCCSeasons = await Competition.find({
            competitionMetaId: ccMeta._id,
            'linkedLeagueSeason.competition': competition.competitionMetaId,
            'linkedLeagueSeason.season': competition._id
        });
        
        if (existingCCSeasons.length > 0) {
            console.log('   ‚è≠Ô∏è  Skipping: CC season already exists for this league season');
            return;
        }
        
        // 3. Check if there's already an active CC season (read-only, no session needed)
        const activeCCSeasons = await Competition.find({
            competitionMetaId: ccMeta._id,
            isActive: true
        });
        
        if (activeCCSeasons.length > 0) {
            console.log('   ‚è≠Ô∏è  Skipping: An active CC season already exists');
            console.log(`      Active CC: ${activeCCSeasons[0]._id} (S${activeCCSeasons[0].seasonMeta.seasonNumber})`);
            return;
        }
        
        // 4. Find latest CC season number (read-only, no session needed)
        const latestCCSeason = await Competition.findOne({
            competitionMetaId: ccMeta._id
        })
        .sort({ 'seasonMeta.seasonNumber': -1 })
        .limit(1);
        
        const newCCSeasonNumber = (latestCCSeason?.seasonMeta?.seasonNumber || 0) + 1;
        console.log(`   üìä New CC season number: ${newCCSeasonNumber}`);
        
        // 5. Query final standings for all 3 divisions
        const selectedFighters = [];
        
        for (let divisionNumber = 1; divisionNumber <= 3; divisionNumber++) {
            // Note: Not using .session(session) because standings were created in previous transactions
            const finalStandings = await RoundStandings.findOne({
                competitionId: competition.competitionMetaId,
                seasonNumber: competition.seasonMeta.seasonNumber,
                divisionNumber: divisionNumber
            })
            .sort({ roundNumber: -1 })
            .limit(1);
            
            if (!finalStandings || !finalStandings.standings) {
                console.error(`   ‚ùå Error: No standings found for Division ${divisionNumber}`);
                return;
            }
            
            // Sort by rank (should already be sorted, but ensuring)
            const sortedStandings = finalStandings.standings.sort((a, b) => a.rank - b.rank);
            
            // Select top fighters based on division
            const topCount = divisionNumber === 3 ? 2 : 3; // D1: 3, D2: 3, D3: 2
            const topFighters = sortedStandings.slice(0, topCount).map(s => s.fighterId);
            
            if (topFighters.length < topCount) {
                console.error(`   ‚ùå Error: Division ${divisionNumber} doesn't have ${topCount} fighters`);
                return;
            }
            
            selectedFighters.push(...topFighters);
            
            const emoji = divisionNumber === 1 ? 'ü•á' : divisionNumber === 2 ? 'ü•à' : 'ü•â';
            console.log(`   ${emoji} Division ${divisionNumber} - Top ${topCount}: ${topFighters.map(id => id.toString().substring(0, 8) + '...').join(', ')}`);
        }
        
        if (selectedFighters.length !== 8) {
            console.error(`   ‚ùå Error: Could not select exactly 8 fighters (got ${selectedFighters.length})`);
            return;
        }
        
        console.log(`   ‚úÖ Selected 8 fighters for CC season`);
        
        // 6. Create random pairings for Round 1 (4 fights)
        const shuffledFighters = [...selectedFighters].sort(() => Math.random() - 0.5);
        const round1Fights = [];
        
        for (let i = 0; i < 4; i++) {
            const fighter1 = shuffledFighters[i * 2];
            const fighter2 = shuffledFighters[i * 2 + 1];
            const fightIdentifier = `CC-S${newCCSeasonNumber}-R1-F${i + 1}`;
            
            round1Fights.push({
                fighter1,
                fighter2,
                winner: null,
                fightIdentifier,
                date: null,
                userDescription: null,
                genAIDescription: null,
                isSimulated: false,
                fighterStats: [],
                fightStatus: 'scheduled'
            });
            
            console.log(`   ü•ä Fight ${i + 1}: ${fighter1.toString().substring(0, 8)}... vs ${fighter2.toString().substring(0, 8)}...`);
        }
        
        // 7. Create CC season document
        const newCCSeason = new Competition({
            competitionMetaId: ccMeta._id,
            isActive: true,
            seasonMeta: {
                seasonNumber: newCCSeasonNumber,
                startDate: new Date(),
                endDate: null,
                winners: [],
                leagueDivisions: null,
                cupParticipants: {
                    fighters: selectedFighters
                }
            },
            leagueData: null,
            cupData: {
                fights: round1Fights,
                currentStage: 'Round 1',
                rounds: null
            },
            config: {
                leagueConfiguration: null,
                cupConfiguration: {
                    knockoutRounds: 3,
                    numberOfFighters: 8,
                    perFightFeeInEur: 15000,
                    winningFeeInEur: 150000,
                    stages: ['Round 1', 'Semi-finals', 'Finals']
                }
            },
            linkedLeagueSeason: {
                competition: competition.competitionMetaId,
                season: competition._id
            }
        });
        
        await newCCSeason.save({ session });
        
        console.log('\n‚ú® CC Season created successfully!');
        console.log(`   üèÜ Season: CC S${newCCSeasonNumber}`);
        console.log(`   üë• Participants: 8 fighters (top-ranked from league)`);
        console.log(`   ü•ä Round 1 Fights: 4 (all scheduled)`);
        console.log(`   üîó Linked to: League ${competition._id.toString().substring(0, 8)}... S${competition.seasonMeta.seasonNumber}`);
        console.log(`   üíæ Saved to MongoDB: ${newCCSeason._id}`);
        
    } catch (error) {
        console.error('   ‚ùå Error creating CC season:', error.message);
        console.error('   Full error:', error);
        console.error('   Stack:', error.stack);
        throw error; // Will trigger transaction rollback
    }
}

/**
 * ====================================================================================
 * MAIN FUNCTION: APPLY COMPLETE FIGHT RESULT
 * ====================================================================================
 * Orchestrates all 8 steps in a single MongoDB transaction
 */
export async function applyFightResult(
    competitionId,
    seasonNumber,
    divisionNumber,
    roundNumber,
    fightIndex,
    fighter1Id,
    fighter2Id,
    generatedResult,
    isSimulated,
    userDescription,
    fightDate
) {
    console.log('\nüöÄ ========================================');
    console.log('   APPLYING FIGHT RESULT');
    console.log('========================================');
    
    const dbStartTime = Date.now();
    const session = await Fighter.startSession();
    session.startTransaction();
    
    try {
        // Fetch competition
        const competition = await Competition.findById(competitionId)
            .populate('competitionMetaId')
            .session(session);
        
        if (!competition) {
            throw new Error('Competition not found');
        }
        
        const competitionType = competition.leagueData ? 'league' : 'cup';
        console.log(`üìä Competition Type: ${competitionType.toUpperCase()}`);
        
        // Find the fight
        let fight;
        if (competitionType === 'league') {
            const division = competition.leagueData.divisions.find(d => d.divisionNumber === divisionNumber);
            if (!division) throw new Error(`Division ${divisionNumber} not found`);
            
            const round = division.rounds.find(r => r.roundNumber === roundNumber);
            if (!round) throw new Error(`Round ${roundNumber} not found`);
            
            fight = round.fights[fightIndex];
        } else {
            fight = competition.cupData.fights[fightIndex];
        }
        
        if (!fight) throw new Error(`Fight at index ${fightIndex} not found`);
        
        const fightIdentifier = fight.fightIdentifier;
        console.log(`ü•ä Fight: ${fightIdentifier}`);
        console.log(`üë§ Fighter 1: ${fighter1Id.toString().substring(0, 8)}...`);
        console.log(`üë§ Fighter 2: ${fighter2Id.toString().substring(0, 8)}...`);
        console.log(`üèÜ Winner: ${generatedResult.winnerId.toString().substring(0, 8)}...`);
        
        // Fetch fighters
        const [fighter1, fighter2] = await Promise.all([
            Fighter.findById(fighter1Id).session(session),
            Fighter.findById(fighter2Id).session(session)
        ]);
        
        if (!fighter1 || !fighter2) {
            throw new Error('One or both fighters not found');
        }
        
        const fighter1IsWinner = generatedResult.winnerId.toString() === fighter1Id.toString();
        const fighter2IsWinner = !fighter1IsWinner;
        
        // STEP 1-2: Update fight document
        await updateCompetitionFight(competition, fight, generatedResult, isSimulated, userDescription, fightDate);
        
        // Get fighter stats from generated result
        const fighter1Stats = generatedResult.fighterStats.find(fs => fs.fighterId.toString() === fighter1Id.toString())?.stats;
        const fighter2Stats = generatedResult.fighterStats.find(fs => fs.fighterId.toString() === fighter2Id.toString())?.stats;
        
        if (!fighter1Stats || !fighter2Stats) {
            throw new Error('Fighter stats not found in generated result');
        }
        
        // STEPS 3-7C: Update Fighter 1
        console.log(`\n${'='.repeat(70)}`);
        console.log(`UPDATING FIGHTER 1: ${fighter1.firstName} ${fighter1.lastName}`);
        console.log(`${'='.repeat(70)}`);
        
        await updateFighterCompetitionHistory(fighter1, competition.competitionMetaId._id, fighter1IsWinner);
        await updateFighterSeasonDetails(fighter1, competition.competitionMetaId._id, seasonNumber, divisionNumber, fighter1IsWinner, competitionType, fightIdentifier);
        await updateFighterOpponentsHistory(fighter1, fighter2Id, competition.competitionMetaId._id, seasonNumber, divisionNumber, roundNumber, fight._id, fighter1IsWinner, fight.date, fightIdentifier);
        await updateFighterDebutInformation(fighter1, competition.competitionMetaId._id, seasonNumber, fight._id, fight.date);
        await updateFighterStreaks(fighter1, competition.competitionMetaId._id, seasonNumber, divisionNumber, roundNumber, fighter2Id, fighter1IsWinner);
        await updateFighterFightStats(fighter1, fighter1Stats);
        
        // STEPS 3-7C: Update Fighter 2
        console.log(`\n${'='.repeat(70)}`);
        console.log(`UPDATING FIGHTER 2: ${fighter2.firstName} ${fighter2.lastName}`);
        console.log(`${'='.repeat(70)}`);
        
        await updateFighterCompetitionHistory(fighter2, competition.competitionMetaId._id, fighter2IsWinner);
        await updateFighterSeasonDetails(fighter2, competition.competitionMetaId._id, seasonNumber, divisionNumber, fighter2IsWinner, competitionType, fightIdentifier);
        await updateFighterOpponentsHistory(fighter2, fighter1Id, competition.competitionMetaId._id, seasonNumber, divisionNumber, roundNumber, fight._id, fighter2IsWinner, fight.date, fightIdentifier);
        await updateFighterDebutInformation(fighter2, competition.competitionMetaId._id, seasonNumber, fight._id, fight.date);
        await updateFighterStreaks(fighter2, competition.competitionMetaId._id, seasonNumber, divisionNumber, roundNumber, fighter1Id, fighter2IsWinner);
        await updateFighterFightStats(fighter2, fighter2Stats);
        
        // Calculate and save round standings (league only)
        console.log(`\nüéØ About to calculate standings - Competition Type: ${competitionType}, Division: ${divisionNumber}, Round: ${roundNumber}`);
        await calculateAndSaveRoundStandings(competition, fightIdentifier, divisionNumber, roundNumber, competitionType, session);
        
        // Update division currentRound (league only)
        updateDivisionCurrentRound(competition, divisionNumber, roundNumber, competitionType);
        
        // Handle cup bracket progression (cup only)
        await handleCupBracketProgression(competition, fightIdentifier, generatedResult.winnerId, competitionType, session);
        
        // Check season completion
        const isSeasonComplete = checkSeasonCompletion(competition);
        if (isSeasonComplete) {
            competition.isActive = false;
            competition.seasonMeta.endDate = new Date();
            console.log(`\nüèÅ Season marked as complete`);
            
            // Populate division winners (league only)
            if (competitionType === 'league') {
                await populateDivisionWinners(competition, session);
                // Batch titles and positions together to avoid version conflicts
                await updateDivisionWinnerTitlesAndPositions(competition, session);
            }
            
            // Update cup winner title and positions (cup only)
            if (competitionType === 'cup') {
                await updateCupWinnerTitleAndPositions(competition, session);
            }
            
            // Create CC season at 100% completion (league only)
            if (competitionType === 'league') {
                await checkAndCreateCCSeasonIfNeeded(competition, session);
            }
        }
        
        // Check for IC season creation at 25% completion (league only)
        if (competitionType === 'league') {
            await checkAndCreateICSeasonIfNeeded(competition, session);
        }
        
        // Check if this is the first fight of the season
        const allFights = competitionType === 'league' 
            ? competition.leagueData.divisions.flatMap(d => d.rounds.flatMap(r => r.fights))
            : competition.cupData.fights;
        
        const isFirstFight = allFights.filter(f => f.fightStatus === 'completed' || f.winner).length === 1;
        
        if (isFirstFight && !competition.seasonMeta.createdAt) {
            competition.seasonMeta.createdAt = new Date();
            console.log(`\nüéâ First fight of the season! Setting createdAt timestamp`);
        }
        
        // For cup finals, add title to the winner before saving
        if (competitionType === 'cup' && fightIdentifier.includes('-FN-')) {
            const winner = fighter1IsWinner ? fighter1 : fighter2;
            const compHistory = winner.competitionHistory.find(
                ch => ch.competitionId.toString() === competition.competitionMetaId._id.toString()
            );
            
            if (compHistory) {
                if (!compHistory.titles) {
                    compHistory.titles = { totalTitles: 0, details: [] };
                }
                
                const existingTitle = compHistory.titles.details.find(
                    t => t.seasonNumber === seasonNumber
                );
                
                if (!existingTitle) {
                    compHistory.titles.details.push({
                        competitionSeasonId: competition._id,
                        seasonNumber,
                        divisionNumber: null
                    });
                    compHistory.titles.totalTitles = (compHistory.titles.totalTitles || 0) + 1;
                    console.log(`\nüèÜ ${winner.firstName} ${winner.lastName}: Cup title added (Total: ${compHistory.titles.totalTitles})`);
                }
            }
        }
        
        // Save all changes
        await competition.save({ session });
        await fighter1.save({ session });
        await fighter2.save({ session });
        
        // Commit transaction
        await session.commitTransaction();
        
        const dbDuration = Date.now() - dbStartTime;
        console.log(`‚è±Ô∏è  Database operations completed in ${dbDuration}ms (${(dbDuration / 1000).toFixed(2)}s)`);
        
        console.log('\n‚úÖ ========================================');
        console.log('   ALL UPDATES COMMITTED SUCCESSFULLY');
        console.log('========================================\n');
        
        // Auto-trigger global ranking ONLY when CC (Champions Cup) completes (non-blocking)
        // CC is the last competition to complete, so we only check once per season
        // This runs AFTER transaction commits, so it won't affect the fight result
        if (isSeasonComplete && competitionType === 'cup') {
            // Check if this is Champions Cup (not IC)
            const competitionName = competition.competitionMetaId?.competitionName || 
                                   (await CompetitionMeta.findById(competition.competitionMetaId))?.competitionName;
            
            if (competitionName === "Champions' Cup") {
                console.log('\nüîç Champions Cup completed - checking if global ranking should be triggered...');
                autoTriggerGlobalRankingIfNeeded(competition).catch(err => {
                    console.error('‚ö†Ô∏è  Error in auto-trigger global ranking:', err.message);
                    // Don't throw - we don't want to fail the fight result if ranking fails
                });
            }
        }
        
        return {
            success: true,
            fightIdentifier,
            winner: generatedResult.winnerId,
            isSeasonComplete
        };
        
    } catch (error) {
        // Rollback on error
        await session.abortTransaction();
        console.error('\n‚ùå ========================================');
        console.error('   TRANSACTION ROLLED BACK');
        console.error('========================================');
        console.error('Error:', error);
        throw error;
    } finally {
        session.endSession();
    }
}

